[{"title":"你好世界!","url":"/2026/01/18/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/","content":"\n本博客建立于2026年1月18日\n我也还没想好写什么\n只是刷题缺少一个放题解的地方\n…\n\n"},{"title":"题解-nico和niconiconi","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-nico%E5%92%8Cniconiconi/","content":"题目链接\n 题意\n\n给定一个长为n字符串s\n其中字串nico,niconi,niconiconi的价值分别是A,B,C\n统计该字符串能获得的最大值\n\n 思路\n\n线性dp\n只不过换了一种形式,依旧是dp[i]表示到第i位能获得的最大价值\n只不过每次检查当前位置作为末尾能不能提取出一个上述三种字串\n转移方程\n\n\n没有匹配的上的\ndp[i]=dp[i−1]dp[i]=dp[i-1]\ndp[i]=dp[i−1]\n\n\n匹配上nico\ndp[i]=max(dp[i−1],dp[i−4]+A)dp[i]=max(dp[i-1],dp[i-4]+A)\ndp[i]=max(dp[i−1],dp[i−4]+A)\n\n\n剩余的同理\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n, a, b, c;  string s;  cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;  cin &gt;&gt; s;  s = &#x27; &#x27; + s;  vector&lt;ll&gt; dp(n + 1, 0);  for (int i = 1; i &lt;= n; i++) &#123;    dp[i] = max(dp[i], dp[i - 1]);    if (i &gt;= 4 &amp;&amp; s.substr(i - 3, 4) == &quot;nico&quot;) &#123;      dp[i] = max(dp[i], dp[i - 4] + a);    &#125;    if (i &gt;= 6 &amp;&amp; s.substr(i - 5, 6) == &quot;niconi&quot;) &#123;      dp[i] = max(dp[i], dp[i - 6] + b);    &#125;    if (i &gt;= 10 &amp;&amp; s.substr(i - 9, 10) == &quot;niconiconi&quot;) &#123;      dp[i] = max(dp[i], dp[i - 10] + c);    &#125;  &#125;  cout &lt;&lt; dp[n] &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n","categories":["算法竞赛"],"tags":["题解","线性dp"]},{"title":"题解-Boredom","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-Boredom/","content":"题目链接\n 题意\n\n给定一个长为n的数组a,可以进行任意次操作\n每次操作选择序列中的一个元素aia_iai​,删掉aia_iai​,获得aia_iai​的分值,同时删除所有值为ai+1,ai−1a_i+1,a_i-1ai​+1,ai​−1的元素\n求解能获得的最大分数\n\n 思路\n\n线性dp变种\n数组的原顺序是不重要的,我们其实更在乎的是能拿哪些值\n如果我们拿了一个值x,那么所有值为x的元素我们都会拿,所以删除和取都应该是全拿全删\n所以数组的形态不重要,更重要的是获得每个值出现的次数\n我们可以用一个map来记录每个值出现的次数,然后用一个dp数组来记录能获得的最大分数\n那么就变成了经典的不相邻取数问题\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  map&lt;int, int&gt; mp;  int mx = 0;  for (int i = 1; i &lt;= n; i++) &#123;    int x;    cin &gt;&gt; x;    mp[x]++;    mx = max(x, mx);  &#125;  vector&lt;ll&gt; dp(mx + 10, 0);  dp[1] = mp[1];  for (int i = 2; i &lt;= mx; i++) &#123;    dp[i] = max(dp[i - 1], dp[i - 2] + mp[i] * i);  &#125;  cout &lt;&lt; dp[mx] &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","线性dp","妙妙题"]},{"title":"题解-不相邻取数","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E4%B8%8D%E7%9B%B8%E9%82%BB%E5%8F%96%E6%95%B0/","content":"题目链接\n 题意\n\n给定长为n的序列,取出一些不相邻的数,求能获得的最大和\n\n 思路\n\n由于前两天被方案类的dp折磨了,所以也写了个方案dp解法\n歪解:\n\n把dp的状态做成二维,dp[i][0/1]表示前i个数,第i个数选取/不选取能获得的最大和\n转移方程:\n\n\ndp[i][0]=max(dp[i−1][0],dp[i−1][1])dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])\ndp[i][0]=max(dp[i−1][0],dp[i−1][1])\n\n\ndp[i][1]=max(a[i],a[i]+dp[i−1][0])dp[i][1] = max(a[i], a[i] + dp[i - 1][0])\ndp[i][1]=max(a[i],a[i]+dp[i−1][0])\n\n\n\n\n\n正解:\n\n线性dp\n定义dp[i]表示前i个数能获得的最大和\n转移方程:\n\n\ndp[i]=max(dp[i−1],dp[i−2]+a[i])dp[i] = max(dp[i - 1], dp[i - 2] + a[i])\ndp[i]=max(dp[i−1],dp[i−2]+a[i])\n\n\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;/** * dp[n][2] * dp[i][0]=max(dp[i-1][0],dp[i-1][1]) * dp[i][1]=max(a[i],a[i]+dp[i-1][0]) * 初始化:全0就行 */int main() &#123;  ios::sync_with_stdio(false);  cin.tie(0), cout.tie(0);  int n;  cin &gt;&gt; n;  vector&lt;ll&gt; a(n + 10);  vector&lt;vector&lt;ll&gt;&gt; dp(n + 10, vector&lt;ll&gt;(2));  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  for (int i = 1; i &lt;= n; i++) &#123;    dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);    dp[i][1] = max(a[i], a[i] + dp[i - 1][0]);    // cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; dp[i][0] &lt;&lt; &#x27; &#x27; &lt;&lt; dp[i][1] &lt;&lt; endl;  &#125;  cout &lt;&lt; max(dp[n][0], dp[n][1]) &lt;&lt; endl;  return 0;&#125;\n","categories":["算法竞赛"],"tags":["题解","线性dp"]},{"title":"题解-x_to_y_2","url":"/2026/01/18/%E9%A2%98%E8%A7%A3-x-to-y-2/","content":"题目链接\n 题意\n\n给定两个整数x和y,可以进行如下两种操作:\n\nx=⌊x2⌋x=\\lfloor \\frac{x}{2} \\rfloorx=⌊2x​⌋\n选定任意数字zzz,x=x∣zx=x|zx=x∣z\n\n\n求最少多少次操作能让xxx变为yyy\n\n 思路\n\n拆位来看,想让x变成y,y已经为1的部分只需要和x进行一次|即可完成\n但y为0的部分无法通过|完成,所以只能通过移位,直到x剩余的所有位都能和y对上,这时候在看情况进行|操作\n看什么情况呢:如果移位完后x==y就不需要|操作了\n\n 代码\n#include&lt;bits/stdc++.h&gt;using namespace std;void solve()&#123;    long long x,y;    cin &gt;&gt; x &gt;&gt; y ;    if(x==y) cout &lt;&lt; 0 &lt;&lt; endl;    else if ((x|y)==y) cout &lt;&lt; 1 &lt;&lt; endl;    else&#123;        int cnt=0;        while(x)&#123;            if((x|y)==y) break;            x&gt;&gt;=1;            cnt++;        &#125;        cout &lt;&lt; cnt+1 &lt;&lt; endl;    &#125;&#125;int main()&#123;    int t;    cin &gt;&gt; t;    while(t--)&#123;        solve();    &#125;    return 0;&#125;","categories":["算法竞赛"],"tags":["题解","位运算"]},{"title":"训练赛-NK-Week-R127","url":"/2026/01/19/%E8%AE%AD%E7%BB%83%E8%B5%9B-NK-Week-R127/","content":"题目链接\n A\n\n签到题,白给\n\n B\n\n小模拟\n\n 题意\n\n给定4*4数组,用1,2,3,4填充\n检查是否每行,每列,每块(2*2子数组(左上,左下,右上,右下))都有1,2,3,4\n\n 思路\n\n标记数组硬搞就行,但是每块的判断比较麻烦,有两种思路\n\n思路一:枚举四个块的左下角,记为(x,y),那么对于每个左下角,还需检查(x-1,y),(x,y-1),(x-1,y-1)即可\n思路二:0-base数组,坐标到块号的转移是(x/2)*2+(y/2)\n\n\n最后检查的时候注意检查的是1~4,而不是0~3\n\n 代码\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int t;    cin &gt;&gt; t;    int a[5][5];    while(t--)&#123;        bool hang[5][5],lie[5][5],kuai[5][5];        for(int i=0;i&lt;4;i++)&#123;            for(int j=1;j&lt;=4;j++)&#123;                hang[i][j]=lie[i][j]=kuai[i][j]=false;            &#125;        &#125;        for(int i=0;i&lt;4;i++)&#123;            for(int j=0;j&lt;4;j++)&#123;                cin &gt;&gt; a[i][j];                hang[i][a[i][j]]=true;                lie[j][a[i][j]]=true;                kuai[(i/2)*2+(j/2)][a[i][j]]=true;            &#125;        &#125;        bool ok=true;        for(int i=0;i&lt;4;i++)&#123;            for(int j=1;j&lt;=4;j++)&#123;                if(!hang[i][j]||!lie[i][j]||!kuai[i][j]) &#123;                    ok=false;                &#125;            &#125;        &#125;        cout &lt;&lt; (ok?&quot;YES&quot;:&quot;NO&quot;) &lt;&lt; endl;    &#125;&#125;\n C\n\n白给小模拟\n\n D\n\n简单组合数学+递推\n\n 题意\n\n给定一个序列,求其中的双排列子数组的个数\n\n 思路\n\n搞一个map,统计每个数出现的次数\n搞一个计数数组f,f[i]表示长度为i的双排列的个数\n\nf[i]=f[i−1]∗Ccnt[i]2f[i]=f[i-1]*C_{cnt[i]}^{2}f[i]=f[i−1]∗Ccnt[i]2​\n如果cnt[i]&lt;=2就停止\n\n\n最后总次数就是对f做累加即可\n\n 代码\n#include&lt;bits/stdc++.h&gt;using namespace std;long long cnt[202020];const int p=998244353;void solve()&#123;    int n;    cin &gt;&gt; n;    map&lt;long long,long long&gt; mp;    mp.clear();    cnt[0]=1;    for(int i=1;i&lt;=n;i++)&#123;        int x;        cin &gt;&gt; x;        mp[x]++;        cnt[i]=0;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        if(mp[i]&lt;=1) break;        cnt[i]=(cnt[i-1]*mp[i]*(mp[i]-1)/2)%p;        // cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; mp[i] &lt;&lt;&#x27; &#x27; &lt;&lt; cnt[i] &lt;&lt; endl;    &#125;    long long ans=0;    for(int i=1;i&lt;=n;i++)&#123;        ans=(ans+cnt[i])%p;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;\n E\n\n方案数dp or 思维\n\n 题意\n\nT组\n给定一个由0,1,?组成的字符串s,定义s是平衡的当且仅当s中相邻相同对数为偶数,你可以将?替换成0或1使得s变平衡\n求解s可能变成的平衡串个数\n\n 思路\n\n有脑做法:\n\ncnt相同=cnt总对数−cnt不同cnt_{相同}=cnt_{总对数}-cnt_{不同}cnt相同​=cnt总对数​−cnt不同​\ncnt不同的奇偶性=⊕i=1n−1(cnti⊕cnti+1)cnt_{不同}的奇偶性=\\oplus_{i=1}^{n-1}(cnt_{i} \\oplus cnt_{i+1})cnt不同​的奇偶性=⊕i=1n−1​(cnti​⊕cnti+1​)\n右式=cnt1⊕cnt2⊕cnt2⊕cnt3...=cnt1⊕cntn右式=cnt_{1} \\oplus cnt_{2} \\oplus cnt_{2} \\oplus cnt_{3}...=cnt_{1} \\oplus cnt_{n}右式=cnt1​⊕cnt2​⊕cnt2​⊕cnt3​...=cnt1​⊕cntn​\ncnt相同=n−1的奇偶性−cnt1⊕cntn的奇偶性cnt_{相同}=n-1的奇偶性-cnt_1\\oplus cnt_n的奇偶性cnt相同​=n−1的奇偶性−cnt1​⊕cntn​的奇偶性\n分类讨论\n\nn-1为奇数\n\n异或项为奇数-&gt;2cnt[中间的?]2^{cnt[中间的?]}2cnt[中间的?]\n异或项为偶数-&gt;0\n\n\nn-1为偶数\n\n异或项为奇数-&gt;0\n异或项为偶数-&gt;2cnt[中间的?]2^{cnt[中间的?]}2cnt[中间的?]\n\n\n\n\n注意:如果两头都是问号方案数要乘2\n\n\n无脑做法\n\ndp搞一下\ndp的值表示当前位置的方案数\n状态设计:\n\n当前位置的方案数有两种:奇数和偶数\n当前位置的方案数由上一位置的方案数和当前位置的数字决定决定\n所以状态中要包含当前位置的数字和当前是奇数还是偶数\ndp[i][j(1/0)][k(1/0)]dp[i][j(1/0)][k(1/0)]dp[i][j(1/0)][k(1/0)]表示前i个数,第i位填j,相邻相同对是k(奇数还是偶数)\n\n\n直接写就行\n优化:注意到每次转移只和前一位有关,所以可以滚动数组优化空间\n\n\n\n 代码(没写回滚)\n#include&lt;bits/stdc++.h&gt;using namespace std;/** * dp[i][j][k]:到第i个位置,第i个位置是j,前面相同对数是k(0-偶数,1-奇数) * dp[i][j][k]=dp[i-1][j][1-k]+dp[i-1][1-j][k] * 根据a[i]的内容决定更新一个还是两个,不更新的那个置0; * 最后ans=dp[n][0][0]+dp[n][1][0] */const int p=998244353;long long dp[505050][2][2];void solve()&#123;    string s;    cin &gt;&gt; s;        memset(dp,0,sizeof(dp));    if(s[0]==&#x27;0&#x27;||s[0]==&#x27;?&#x27;)dp[0][0][0]=1;    if(s[0]==&#x27;1&#x27;||s[0]==&#x27;?&#x27;)dp[0][1][0]=1;    /**     * 回滚就是维护f[2][2],g[2][2]     * 下面的for循环内每次清空g     * 然后g[][]=f[][]+f[][]     * 最后f=g     * 答案就是f[0][0]+f[1][0]     * */    for(int i=1;i&lt;s.size();i++)&#123;        if(s[i]==&#x27;0&#x27;||s[i]==&#x27;?&#x27;)&#123;            for(int k=0;k&lt;2;k++)&#123;                dp[i][0][k]=(dp[i-1][0][1-k]+dp[i-1][1][k])%p;            &#125;        &#125;        if(s[i]==&#x27;1&#x27;||s[i]==&#x27;?&#x27;)&#123;            for(int k=0;k&lt;2;k++)&#123;                dp[i][1][k]=(dp[i-1][1][1-k]+dp[i-1][0][k])%p;            &#125;        &#125;    &#125;    cout &lt;&lt; (dp[s.size()-1][0][0]+dp[s.size()-1][1][0])%p &lt;&lt; endl;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;\n F\n\nbfs-类似于泛洪问题\n\n 题意\n\n给定一个n*n01矩阵\n对于每个0如果他的上下左右有两个对角相邻的1,那么下一时刻他就变成1\n求矩阵的最终状态\nn&lt;=2000\n\n 思路\n\n正解:\n\n写一个check判断下一时刻会不会变成1\n读入的时候把所有会变成1的0入队,标上vis,改地图\n然后bfs,每次出队的时候判断上下左右的0会不会变成1,会的话入队\n直到队列为空\n\n\n我的思路:\n\n写一个check判断下一时刻会不会变成1\n所有1入队\nbfs,每次出队判断一下周围的0会不会变,如果会变就入队\n直到队列为空\n\n\n\n 代码\n#include&lt;bits/stdc++.h&gt;using namespace std;#define pii pair&lt;int,int&gt;int a[2020][2020];int dir[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;bool check(int x,int y,int tx,int ty)&#123;    if(x!=tx)return (a[tx][ty-1]|a[tx][ty+1]);    else return (a[tx-1][ty]|a[tx+1][ty]);&#125;void solve()&#123;    int n;    cin &gt;&gt; n ;    queue&lt;pii&gt; q;    memset(a,0,sizeof(a));    for(int i=1;i&lt;=n;i++)&#123;        string s;        cin &gt;&gt; s;        for(int j=1;j&lt;=n;j++)&#123;            a[i][j]=s[j-1]-&#x27;0&#x27;;            if(a[i][j]==1) q.push(&#123;i,j&#125;);        &#125;    &#125;    while(!q.empty())&#123;        int nx=q.front().first;        int ny=q.front().second;        q.pop();        for(int i=0;i&lt;4;i++)&#123;            int tx=nx+dir[i][0];            int ty=ny+dir[i][1];            if(a[tx][ty]==1||tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;n) continue;            a[tx][ty]=check(nx,ny,tx,ty);            if(a[tx][ty]==1) q.push(&#123;tx,ty&#125;);        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            cout &lt;&lt; a[i][j];        &#125;        cout &lt;&lt; endl;    &#125;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;","categories":["算法竞赛"],"tags":["训练赛","NK周赛","bfs","方案dp"]},{"title":"题解-小红蹦跳蹦跳","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E7%BA%A2%E8%B9%A6%E8%B7%B3%E8%B9%A6%E8%B7%B3/","content":"题目链接\n 题意\n\n一个n级台阶,交替上升奇数步/偶数步\n第一步可以任意选择,每一步一定和上一步奇偶性不同\n求上n级台阶的方案数\n\n 思路\n\n\n对于某一个位置,如果下一步要走奇数/偶数,那么上一步一定是偶数/奇数\n\n\n所以用dp[i][1/0]表示到第i级,下一步是奇数/偶数的方案数\n\n\n具体转移方案如下\n  i是奇数:dp[i][0]=sum(dp[偶数][1])dp[i][1]=sum(dp[奇数][0])i是偶数:dp[i][0]=sum(dp[奇数][1])dp[i][1]=sum(dp[偶数][0])\n\n\n然后会发现,dp无意义,只有4个sum有意义,维护4个sum即可\n\n\n 代码\n\n优化:发现dp数组其实无意义,只需要记录当前状态\n\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int p = 1e9 + 7;void solve() &#123;  int n;  cin &gt;&gt; n;  ll cur_0 = 0, cur_1 = 0;  vector&lt;vector&lt;ll&gt;&gt; sum(2, vector&lt;ll&gt;(2));  for (int i = 1; i &lt;= n; i++) &#123;    cur_0 = sum[1 - (i % 2)][1];    cur_1 = sum[i % 2][0];    if (i % 2)      cur_0++;    else      cur_1++;    sum[i % 2][0] = (sum[i % 2][0] + cur_0) % p;    sum[i % 2][1] = (sum[i % 2][1] + cur_1) % p;  &#125;  cout &lt;&lt; (cur_0 + cur_1) % p &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n\n不优化\n\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int p = 1e9 + 7;/** * i是奇数 * dp[i][0]=sum(dp[偶数][1]) * dp[i][1]=sum(dp[奇数][0]) * i是偶数 * dp[i][0]=sum(dp[奇数][1]) * dp[i][1]=sum(dp[偶数][0]) */void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;vector&lt;ll&gt;&gt; dp(n + 10, vector&lt;ll&gt;(2));  vector&lt;vector&lt;ll&gt;&gt; sum(2, vector&lt;ll&gt;(2));  for (int i = 1; i &lt;= n; i++) &#123;    dp[i][0] = sum[1 - (i % 2)][1];    dp[i][1] = sum[i % 2][0];    dp[i][1 - i % 2]++;    sum[i % 2][0] = (sum[i % 2][0] + dp[i][0]) % p;    sum[i % 2][1] = (sum[i % 2][1] + dp[i][1]) % p;  &#125;  cout &lt;&lt; (dp[n][0] + dp[n][1]) % p &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n","categories":["算法竞赛"],"tags":["题解","线性dp"]},{"title":"题解-小红删数字","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E7%BA%A2%E5%88%A0%E6%95%B0%E5%AD%97/","content":"每日一题1.21\n 题意\n\n给定长为n的数组,进行n-1此操作,剩下一个数字\n每次操作选定最后两个数x,y,删除\n然后加入(x+y)%10或者x*y%10\n统计,所有可能的操作下,最终结果为0,1,…,9的方案数各有多少\n结果对1e9+7取模\nn&lt;=2e5,a&lt;=1e9\n\n 思路\n\n\n对于最后的情况需要知道所有可能的方案,考虑dp\n\n\n设dp[i][j]表示i次操作,最后一个数字是j的方案数\n\n\n那么,按照下面的公式从后往前递推即可\ndp[i−1][(j+a[i−1])%10]=dp[i−1][(j+a[i−1])%10]+dp[i][j]dp[i-1][(j+a[i-1])\\%10]=dp[i-1][(j+a[i-1])\\%10]+dp[i][j]\ndp[i−1][(j+a[i−1])%10]=dp[i−1][(j+a[i−1])%10]+dp[i][j]\ndp[i−1][(j∗a[i−1])%10]=dp[i−1][(j∗a[i−1])%10]+dp[i][j]dp[i-1][(j*a[i-1])\\%10]=dp[i-1][(j*a[i-1])\\%10]+dp[i][j]\ndp[i−1][(j∗a[i−1])%10]=dp[i−1][(j∗a[i−1])%10]+dp[i][j]\n\n\n坑:n是可以取1的,如果一次操作都做不了且输入的数字大于10,那么方案数应该全是0,得特判\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int p = 1e9 + 7;long long dp[202020][10];long long a[202020];int main() &#123;  int n;  cin &gt;&gt; n;  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  if (n &lt;= 1 &amp;&amp; a[1] &gt;= 10) &#123;    for (int i = 0; i &lt; 10; i++) &#123;      cout &lt;&lt; 0 &lt;&lt; &#x27; &#x27;;    &#125;    return 0;  &#125;  dp[n][a[n] % 10] = 1;  for (int i = n; i &gt;= 1; i--) &#123;    for (int j = 0; j &lt; 10; j++) &#123;      dp[i - 1][(j + a[i - 1]) % 10] =          (dp[i - 1][(j + a[i - 1]) % 10] + dp[i][j]) % p;      dp[i - 1][(j * a[i - 1]) % 10] =          (dp[i - 1][(j * a[i - 1]) % 10] + dp[i][j]) % p;    &#125;  &#125;  for (int i = 0; i &lt;= 9; i++) &#123;    cout &lt;&lt; dp[1][i] &lt;&lt; &#x27; &#x27;;  &#125;  cout &lt;&lt; endl;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","方案dp","每日一题"]},{"title":"题解-区间翻转","url":"/2026/01/18/%E9%A2%98%E8%A7%A3-%E5%8C%BA%E9%97%B4%E7%BF%BB%E8%BD%AC/","content":"\n题目链接\n\n 题意\n\n给定一个排列,最开始是{1,2,…,n}\n进行k次操作\n每次翻转区间[l,r],特别的,区间起始点和终点是非递减的\n\n对于i&lt;j,一定有li&lt;=lj且ri&lt;=rj\n\n\n输出k次操作后的序列\n1&lt;n,k&lt;1e5\n\n 思路\n\n观察发现,记排序p对于当前的区间[l,r],由于非递减,所以p的前l-1个数已经确定了\n同时,由于非递减,所以随着区间的上升,只有可能发生两个事情\n\nl变大,确定的数变多\nr变大,加入更多不确定的数字\n\n\n因此,用一个deque维护当前仍然不确定的数字,并同时用一个布尔变量rev模拟翻转的过程,那么每次操作如下\n\n遍历每一个区间\n如果cur_r&lt;r:新增元素入队\n\nrev=false:区间没翻转直接push_back\nrev=true:区间翻转,所谓的队尾实际应该是队头,push_front\n\n\n如果curl&gt;l:已经毕业的元素弹出\n\nrev=false:区间没翻转直接pop_front\nrev=true:区间翻转,弹出的队首实际上是队尾pop_back\n\n\n每处理完一个区间都要翻转:rev=!rev以此规避模拟过程\n更新cur_l,cur_r\n\n\n注意:\n\n所有区间处理完后,记得处理没排完的数(队列里剩下的&amp;&amp;没入过队的)\n最前面的几个数不用处理,因为前面的数在更新r的时候会强制入队\n\n\n\n 代码\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);cout.tie(0);    int n,k;    cin &gt;&gt; n &gt;&gt; k;    deque&lt;int&gt; dq;    vector&lt;int&gt; ans;    bool rev=false;    int l,r,prel=1,prer=0;    for(int i=0;i&lt;k;i++)&#123;        cin &gt;&gt; l &gt;&gt; r;        if(prer&lt;r)&#123;            for(int j=prer+1;j&lt;=r;j++)&#123;                // cout &lt;&lt; &quot;&gt;&gt;&quot; &lt;&lt; j &lt;&lt; &#x27; &#x27; &lt;&lt; rev &lt;&lt; endl;                if(rev) dq.push_front(j);                else dq.push_back(j);            &#125;        &#125;        if(prel&lt;l)&#123;            for(int j=prel;j&lt;l;j++)&#123;                if(!rev)&#123;                    ans.push_back(dq.front());                    // cout &lt;&lt; &quot;&lt;&lt;&quot; &lt;&lt; dq.front() &lt;&lt; &#x27; &#x27; &lt;&lt; rev &lt;&lt; endl;                    dq.pop_front();                &#125;                else&#123;                    ans.push_back(dq.back());                    // cout &lt;&lt; &quot;&lt;&lt;&quot; &lt;&lt; dq.back() &lt;&lt; &#x27; &#x27; &lt;&lt; rev &lt;&lt; endl;                    dq.pop_back();                &#125;            &#125;        &#125;        prel=l;prer=r;        rev=!rev;    &#125;    while(!dq.empty())&#123;        if(!rev)&#123;            ans.push_back(dq.front());            dq.pop_front();        &#125;else&#123;            ans.push_back(dq.back());            dq.pop_back();        &#125;    &#125;    for(auto i:ans)&#123;        cout &lt;&lt; i &lt;&lt; &#x27; &#x27; ;    &#125;    for(int i=prer+1;i&lt;=n;i++)&#123;        cout &lt;&lt; i &lt;&lt; &#x27; &#x27; ;    &#125;    cout &lt;&lt; endl;    return 0;&#125;","categories":["算法竞赛"],"tags":["题解","deque"]},{"title":"题解-宵暗的妖怪","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E5%AE%B5%E6%9A%97%E7%9A%84%E5%A6%96%E6%80%AA/","content":"题目链接\n 题意\n\n给定一个长为n的序列\n可以选择连续的3个元素,删除,获得中间那个元素的值\n求能获得的最大值\n\n 思路\n\n歪解:\n\n依旧方案dp\ndp[i][1/0]前i个元素,选择/不选择第i个元素,能获得的最大值\n转移方程:\n\n\ndp[i][0]=max(dp[i−1][0],dp[i−1][1])dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])\ndp[i][0]=max(dp[i−1][0],dp[i−1][1])\n\n\ndp[i][1]=a[i−1]+max(dp[i−3][0],dp[i−3][1])dp[i][1] = a[i - 1] + max(dp[i - 3][0], dp[i - 3][1])\ndp[i][1]=a[i−1]+max(dp[i−3][0],dp[i−3][1])\n\n\n\n\n\n正解:\n\n线性dp\ndp[i]表示前i个数能获得的最大值\n转移方程:\n\n\ndp[i]=max(dp[i−1],dp[i−3]+a[i−1])dp[i]=max({dp[i-1],dp[i-3]+a[i-1]})\ndp[i]=max(dp[i−1],dp[i−3]+a[i−1])\n\n\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;long long&gt; a(n + 10);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  vector&lt;long long&gt; dp(n + 10);  dp[1] = a[1];  dp[2] = max(0ll, a[1] + a[2]);  for (int i = 3; i &lt;= n; i++) &#123;    dp[i] = max(&#123;dp[i - 2], dp[i - 3], dp[i - 1] + a[i]&#125;);  &#125;  cout &lt;&lt; dp[n] &lt;&lt; endl;&#125;int main() &#123;  int t;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","线性dp"]},{"title":"题解-小红的双排列删除得分","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E7%BA%A2%E7%9A%84%E5%8F%8C%E6%8E%92%E5%88%97%E5%88%A0%E9%99%A4%E5%BE%97%E5%88%86/","content":"题目链接\n 题意\n\n给定一个长为2n的双排列,可以进行如下操作任意次:\n\n选定一个首尾元素相等的区间[l,r]\n删除这个区间,获得区间中所有值的和\n\n\n求出可能的最高分\n\n 思路\n\n线性dp,很神奇的思路\ndp[i]依旧表示前i个元素的最高分\n怎么转移?\n\n对于第i个元素,可以删也可以不删\n删掉的话需要快速的获得上一次的位置和区间和\n维护两个数组即可\n\n\n转移方程\n\n\ndp[i]=max(dp[i−1],dp[a[i]上一次出现的位置−1]+区间和)dp[i]=max(dp[i-1],dp[a[i]上一次出现的位置-1]+区间和)\ndp[i]=max(dp[i−1],dp[a[i]上一次出现的位置−1]+区间和)\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;long long&gt; a(n + 10);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  vector&lt;long long&gt; dp(n + 10);  dp[1] = a[1];  dp[2] = max(0ll, a[1] + a[2]);  for (int i = 3; i &lt;= n; i++) &#123;    dp[i] = max(&#123;dp[i - 2], dp[i - 3], dp[i - 1] + a[i]&#125;);  &#125;  cout &lt;&lt; dp[n] &lt;&lt; endl;&#125;int main() &#123;  int t;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","线性dp","妙妙题"]},{"title":"题解-小红选点","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E7%BA%A2%E9%80%89%E7%82%B9/","content":""},{"title":"题解-小苯的最大和","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E8%8B%AF%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/","content":"题目链接\n 题意\n\n给定一个长为n的序列a,可以进行如下操作:\n\n选取两个相邻数字,删除,把剩余数字拼接起来\n选取三个连续数字,删除,把剩余数字拼接起来\n\n\n你可以执行任意次,想知道a的总和最大可以达到多少?\n\n 思路\n\n线性dp\n定义dp[i]表示a的前i个数字的最大和\\\n状态转移:\n\n\ndp[i]=max(dp[i−2],dp[i−3],dp[i−1]+a[i])dp[i] = max({dp[i - 2], dp[i - 3], dp[i - 1] + a[i]})\ndp[i]=max(dp[i−2],dp[i−3],dp[i−1]+a[i])\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;long long&gt; a(n + 10);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  vector&lt;long long&gt; dp(n + 10);  dp[1] = a[1];  dp[2] = max(0ll, a[1] + a[2]);  for (int i = 3; i &lt;= n; i++) &#123;    dp[i] = max(&#123;dp[i - 2], dp[i - 3], dp[i - 1] + a[i]&#125;);  &#125;  cout &lt;&lt; dp[n] &lt;&lt; endl;&#125;int main() &#123;  int t;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","线性dp"]},{"title":"题解-[模板]点线位置关系","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-%E6%A8%A1%E6%9D%BF-%E7%82%B9%E7%BA%BF%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB/","content":""},{"title":"题解-最长不下降子序列","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/","content":"题目链接\n 题意\n\n给定一个长为n的序列,计算最长不下降子序列长度\nn&lt;=5e3\n\n 思路\n\ndp[i]表示前i个数,必须取第i个数的情况下的最长不下降子序列\n由于题目范围允许O(n^2),所以很容易想到,每次和前面所有的所比较\n转移方程:\n\n\ndp[i]=max(dp[j]+1)   (a[i]&gt;=a[j]且j&lt;i)dp[i]=max(dp[j]+1)\\,\\,\\,(a[i]&gt;=a[j]且j&lt;i)\ndp[i]=max(dp[j]+1)(a[i]&gt;=a[j]且j&lt;i)\n\n最后答案从全部dp[i]dp[i]dp[i]中取max\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;ll&gt; a(n + 10, 0);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  vector&lt;ll&gt; dp(n + 10, 1);  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt; i; j++) &#123;      if (a[i] &gt;= a[j])        dp[i] = max(dp[i], dp[j] + 1);    &#125;  &#125;  ll ans = 0;  for (int i = 1; i &lt;= n; i++) &#123;    ans = max(ans, dp[i]);  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","线性dp"]},{"title":"题解-收集金币","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-%E6%94%B6%E9%9B%86%E9%87%91%E5%B8%81/","content":"题目链接\n 题意\n\nn*m迷宫,每个格子里有aija_{ij}aij​个金币,初始在(1,1),只能向右向下移动\n有t条信息,(x,y,i),表示(x,y)这个位置,在第i秒后就不可通过\n求最多能获得的金币数\n\n 思路\n\n线性dp小变形\n观察发现,由于只能向右/向下走,所以到达每个格子的时间是固定的\n\n以1-base下标为例t=x+y-2\n\n\n所以信息给出后哪些格子能到哪些不能到就确定了\n两种写法:\n\n写法一:\n\n把不能到的格子处理成一个负的极大值,这样自然就不会走\n\n\n写法二:\n\n转移的时候判断一下是否是不可访问的格子,如果是,就不转移\n\n\n\n\n最后遍历所有位置,找最大值\n\n 代码\n//写法一#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;using ll = long long;void solve() &#123;  int n, m, t;  cin &gt;&gt; n &gt;&gt; m;  vector&lt;vector&lt;ll&gt;&gt; a(n + 10, vector&lt;ll&gt;(m + 10));  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= m; j++) &#123;      cin &gt;&gt; a[i][j];    &#125;  &#125;  cin &gt;&gt; t;  for (int i = 1; i &lt;= t; i++) &#123;    int x, y, z;    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;    if (x + y - 2 &gt;= z)      a[x][y] = -1e9;  &#125;  vector&lt;vector&lt;ll&gt;&gt; dp(n + 10, vector&lt;ll&gt;(m + 10, -1e9));  dp[1][0] = 0;  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= m; j++) &#123;      dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + a[i][j];    &#125;  &#125;  ll ans = 0;  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= m; j++) &#123;      ans = max(ans, dp[i][j]);    &#125;  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n//写法二for (int i = 1; i &lt;= n; ++i) &#123;    for (int j = 1; j &lt;= m; ++j) &#123;        if (i == 1 &amp;&amp; j == 1) continue;        // 检查当前格子是否可达        int arrival_time = i + j - 2;        if (arrival_time &gt;= wall_time[i][j]) &#123;            continue; // 此格子无法进入        &#125;        long long from_up = -INF;        if (i &gt; 1 &amp;&amp; dp[i - 1][j] != -INF) &#123;            from_up = dp[i - 1][j];        &#125;        long long from_left = -INF;        if (j &gt; 1 &amp;&amp; dp[i][j - 1] != -INF) &#123;            from_left = dp[i][j - 1];        &#125;        long long prev_max = max(from_up, from_left);        if (prev_max != -INF) &#123;            dp[i][j] = prev_max + coins[i][j];        &#125;    &#125;&#125;","categories":["算法竞赛"],"tags":["题解","线性dp"]},{"title":"题解-[模板]点线最近距离","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-%E6%A8%A1%E6%9D%BF-%E7%82%B9%E7%BA%BF%E6%9C%80%E8%BF%91%E8%B7%9D%E7%A6%BB/","content":""},{"title":"题解-[模板]点圆位置关系","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-%E6%A8%A1%E6%9D%BF-%E7%82%B9%E5%9C%86%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB/","content":""},{"title":"题解-矩阵的最小路径和","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","content":" 题意\n\nn*m矩阵,起点(1,1),只能向右向下走,求从起点到终点的最小路径和\nn,m&lt;=2000,内存限制:32MB\n\n 思路\n\ndp的想法很简单,处理初值即可\n但是直接开二维数组就会炸(2000*2000*8=32MB,还要考虑其他部分),必须滚动\n发现用到的信息是上一行的同一位置和同一行左侧位置,所以直接就地顺序滚动即可\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123;  int n, m;  cin &gt;&gt; n &gt;&gt; m;  vector&lt;vector&lt;int&gt;&gt; a(n + 10, vector&lt;int&gt;(m + 10));  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= m; j++) &#123;      cin &gt;&gt; a[i][j];    &#125;  &#125;  vector&lt;long long&gt; dp(m + 10, 1e18);  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= m; j++) &#123;      if (i == 1 &amp;&amp; j == 1)        dp[j] = a[i][j];      else        dp[j] = a[i][j] + min(dp[j], dp[j - 1]);    &#125;  &#125;  cout &lt;&lt; dp[m] &lt;&lt; endl;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","就地滚动"]},{"title":"题解-阅读理解","url":"/2026/01/19/%E9%A2%98%E8%A7%A3-%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3/","content":"每日一题-1.19\n 题意\n\nn句话,m次查询,每次查询一个word,升序输出所有出现过word的句子编号\n没出现就输出空行\n\n 思路\n\n\n纯暴力做法\n\n对于每句话维护一个set,每次查询从n个set中查找word\n复杂度是O(nm*log(一句话单词数L)*一个词的字母数S)\ntips:字符串的比较复杂度是要算长度的\n\n\n\n有脑做法:\n\n倒排索引\n不再建立set,而是建立word到句子编号的映射map&lt;string,set&lt;int&gt;&gt;\n这样查询的时候只用遍历word对应的set即可\n复杂度是O(m*S*log(总单词数))\n\n\n\n 代码\n//更优写法#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    map&lt;string,set&lt;int&gt;&gt; mp;    int n;    cin &gt;&gt; n;    for(int i=1;i&lt;=n;i++)&#123;        int x;        cin &gt;&gt; x;        for(int j=0;j&lt;x;j++)&#123;            string s;            cin &gt;&gt; s;            mp[s].insert(i);        &#125;    &#125;    int m;    cin &gt;&gt; m;    for(int i=0;i&lt;m;i++)&#123;        string s;        cin &gt;&gt; s;        if(!mp[s].empty())&#123;            for(auto x:mp[s])&#123;                cout &lt;&lt; x &lt;&lt; &#x27; &#x27; ;            &#125;            cout &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;// #include&lt;bits/stdc++.h&gt;// using namespace std;// int main()&#123;//     int n;//     cin &gt;&gt; n;//     vector&lt;set&lt;string&gt;&gt; a(n);//     for(int i=0;i&lt;n;i++)&#123;//         int x;//         cin &gt;&gt; x;//         for(int j=0;j&lt;x;j++)&#123;//             string s;//             cin &gt;&gt; s;//             a[i].insert(s);//         &#125;//     &#125;//     int m;//     cin &gt;&gt; m;//     for(int i=0;i&lt;m;i++)&#123;//         string check;//         cin &gt;&gt; check;//         for(int j=0;j&lt;n;j++)&#123;//             if(a[j].count(check))&#123;//                 cout &lt;&lt; j+1 &lt;&lt; &#x27; &#x27; ;//             &#125;//         &#125;//         cout &lt;&lt; endl;//     &#125;//     return 0;// &#125;","categories":["算法竞赛"],"tags":["题解","每日一题"]}]