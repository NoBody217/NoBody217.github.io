[{"title":"训练赛-26牛客寒假(II)","url":"/2026/02/09/%E8%AE%AD%E7%BB%83%E8%B5%9B-26%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87-II/","content":"比赛链接\n A.比赛安排\n 题意\n\nT 组询问,每组询问给定小白月赛,练习赛,挑战赛的场次 a,b,ca,b,ca,b,c\n要求排期使得对于任意连续三场的比赛类型都不相同,求是否可能做到\n\n 思路\n\n签到,显然周期为3,所以场次最多的和场次最少的差距不能超过1\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int a, b, c;  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;  cout &lt;&lt; (max(&#123;a, b, c&#125;) - min(&#123;a, b, c&#125;) &lt;= 1 ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n B.NCPC\n 题意\n\n给定nnn个整数,每次可以选定两个整数,若两个数字不等,留下较大值,否则全部删除,问对于每个整数能否是最后剩下的数字\n\n 思路\n\n签到\n对一个整数,如果他自己是最大值\n\n那么判最大值出现次数是不是偶数,偶数就不行,奇数可以\n\n\n如果他自己不是最大值\n\n判最大值出现次数是不是偶数,偶数就可以,奇数就不行\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;ll&gt; a(n + 10);  map&lt;ll, ll, greater&lt;ll&gt;&gt; mp;  ll mx = -1;  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];    mp[a[i]]++;    mx = max(mx, a[i]);  &#125;  for (int i = 1; i &lt;= n; i++) &#123;    if (a[i] == mx) &#123;      if (mp[a[i]] &amp; 1)        cout &lt;&lt; 1;      else        cout &lt;&lt; 0;    &#125; else &#123;      if (!(mp[mx] &amp; 1))        cout &lt;&lt; 1;      else        cout &lt;&lt; 0;    &#125;  &#125;  cout &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n I.01回文\n 题意\n\n有一个n∗mn*mn∗m的01矩阵,对矩阵的每个点询问\n能否由该点出发,上下左右移动,找到一个不同于起点的点,使得整条路径构成一个回文串\n\n 思路\n\n首先,任意两个点之间一定是可达的\n对于任意一个0/1,只要有相同的数字,就一定能构成回文\nPS:这个题卡了endl,找半天没找到问题\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int n, m;void solve() &#123;  cin &gt;&gt; n &gt;&gt; m;  vector&lt;string&gt; s(n + 10);  for (int i = 0; i &lt; n; i++) &#123;    cin &gt;&gt; s[i];  &#125;  int cnt[2] = &#123;0&#125;;  for (int i = 0; i &lt; n; i++) &#123;    for (int j = 0; j &lt; m; j++) &#123;      if (s[i][j] == &#x27;0&#x27;)        cnt[0]++;      else        cnt[1]++;    &#125;  &#125;  vector&lt;string&gt; ans(n + 10);  for (int i = 0; i &lt; n; i++) &#123;    for (int j = 0; j &lt; m; j++) &#123;      if (cnt[s[i][j] - &#x27;0&#x27;] == 1)        ans[i] += &#x27;N&#x27;;      else        ans[i] += &#x27;Y&#x27;;    &#125;  &#125;  for (int i = 0; i &lt; n; i++) &#123;    cout &lt;&lt; ans[i] &lt;&lt; &#x27;\\n&#x27;;  &#125;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n F.x?y?n!\n 题意\n\n给定一个整数nnn,构造两个不相等的整数x,yx, yx,y满足gcd(x,y)=ngcd(x,y) = ngcd(x,y)=n且x⊕yx \\oplus yx⊕y最小\n\n 思路\n\n异或性质:异或可以视为不进位加法或者不退位减法\n也就是说有:x+y≥x⊕y≥∣x−y∣x+y\\geq x\\oplus y\\geq |x-y|x+y≥x⊕y≥∣x−y∣\n又因为两者都是nnn的倍数,所以差值最小就是nnn\n所以构造一个a=C1n,b=C2na=C_1n,b=C_2na=C1​n,b=C2​n,最终使得C1−C2=1C_1-C_2=1C1​−C2​=1即可\n特别的要保证两个数刚好在低位差nnn\n\n 代码\n#include &lt;bits/stdc++.h&gt;#define endl &#x27;\\n&#x27;using namespace std;using ll = long long;void solve() &#123;  ll n;  cin &gt;&gt; n;  cout &lt;&lt; (n &lt;&lt; (31)) &lt;&lt; &#x27; &#x27; &lt;&lt; ((n &lt;&lt; (31) + n) &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n E.01矩阵\n 题意\n\n构造一个nnn阶矩阵满足下列三个条件:\n\nnnn行中行和为0~n-1的各出现一次\nnnn列中列和为0~n-1的各出现一次\n整个nnn阶矩阵有n个连通块\n\n\n\n 思路\n\n神秘构造\n手玩发现,如下形状一定可以满足条件\n\n00001101000000111010001010000001111010000101101010\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;#define endl &#x27;\\n&#x27;using ll = long long;using pii = pair&lt;int, int&gt;;using pll = pair&lt;long long, long long&gt;;void solve() &#123;  int n;  cin &gt;&gt; n;  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= n; j++) &#123;      if (i % 2 == 0 &amp;&amp; j &gt;= i || j % 2 == 0 &amp;&amp; i &gt;= j) &#123;        cout &lt;&lt; 1;      &#125; else &#123;        cout &lt;&lt; 0;      &#125;    &#125;    cout &lt;&lt; endl;  &#125;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n H.权值计算\n 题意\n\n定义一个数组的权值为其所有前缀中不同数字的个数\n求长为nnn的数组的所有子数组的权值之和\n\n 思路\n\n手动模拟一定会T\n考虑计算单个数字产生的贡献和产生贡献的次数\n由于只有不同才能产生贡献,所以对于位于iii的数字合法的左端点取决于上一个相同的数字出现的位置jjj\n所以左端点个数会影响贡献的次数\n右端点个数是固定的,但是不同的位置的贡献次数不一样\n对于固定的左端点,右端点取i,i+1,i+2...ni,i+1,i+2...ni,i+1,i+2...n,分别产生的贡献为1,2,3,...n−i+11,2,3,...n-i+11,2,3,...n−i+1\n化简公式:固定lll时,(n−i+2)(n−i+1)2\\frac{(n-i+2)(n-i+1)}{2}2(n−i+2)(n−i+1)​\n综上,对于每个位置,贡献=(i−j)∗(n−i+2)(n−i+1)2贡献=(i-j)*\\frac{(n-i+2)(n-i+1)}{2}贡献=(i−j)∗2(n−i+2)(n−i+1)​\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;#define int ll#define endl &#x27;\\n&#x27;using ll = long long;using pii = pair&lt;int, int&gt;;using pll = pair&lt;long long, long long&gt;;void solve() &#123;  int n;  cin &gt;&gt; n;  unordered_map&lt;int, int&gt; mp;  vector&lt;int&gt; a(n + 1);  vector&lt;int&gt; b(n + 1);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];    if (!mp.count(a[i])) &#123;      b[i] = 0;    &#125; else &#123;      b[i] = mp[a[i]];    &#125;    mp[a[i]] = i;  &#125;  ll ans = 0;  for (int i = 1; i &lt;= n; i++) &#123;    ans += (i - b[i]) * (n - i + 2) * (n - i + 1) / 2;  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;signed main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n J.终于再见\n 题意\n\nnnn个点的无向图,mmm条边,边权为111\n求解每个点到比它度更大的点的最短路径\n\n 思路\n 前置知识:最短路的多种求法\n\n普遍求法:dijkstra,SPFA\n度为1:BFS\n特殊情况:拓扑排序\n\n 本题思路\n\n最暴力的想法,对每个点求一次BFS,复杂度O(n∗(n+m))O(n*(n+m))O(n∗(n+m))\n肯定超时,怎么优化\n观察发现,度的种类不会超过m\\sqrt{m}m​量级,证明如下\n\n对于kkk个不同的度,他们的加和最少为k∗(k−1)2\\frac{k*(k-1)}{2}2k∗(k−1)​\n又因为一条边贡献两个度,所以k∗(k−1)2≤2m\\frac{k*(k-1)}{2}\\leq 2m2k∗(k−1)​≤2m\n所以kkk是m\\sqrt{m}m​量级\n\n\n那么,正难则反,从度小的点到度大的点等价于找从度大的点到度小的点\n进而我们按照度从大到小,每次把度相同的点扔进队列做多源bfs,复杂度降到O(m∗(n+m))O(\\sqrt{m}*(n+m))O(m​∗(n+m))\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;#define endl &#x27;\\n&#x27;using ll = long long;using pii = pair&lt;int, int&gt;;using pll = pair&lt;long long, long long&gt;;vector&lt;int&gt; G[202020];bool vis[202020];ll dis[202020];void bfs(set&lt;int&gt; st, int lim) &#123;  fill(vis, vis + 202000, 0);  queue&lt;pll&gt; q;  for (auto x : st) &#123;    q.push(&#123;x, 0&#125;);    vis[x] = 1;  &#125;  while (!q.empty()) &#123;    pll u = q.front();    q.pop();    for (auto v : G[u.first]) &#123;      if (vis[v] || G[v].size() &gt;= lim)        continue;      vis[v] = 1;      dis[v] = min(dis[v], u.second + 1);      q.push(&#123;v, u.second + 1&#125;);    &#125;  &#125;&#125;void solve() &#123;  fill(dis, dis + 202000, 1e9);  int n, m;  cin &gt;&gt; n &gt;&gt; m;  for (int i = 1; i &lt;= m; i++) &#123;    int u, v;    cin &gt;&gt; u &gt;&gt; v;    G[u].push_back(v);    G[v].push_back(u);  &#125;  map&lt;int, set&lt;int&gt;, greater&lt;int&gt;&gt; mp;  for (int i = 1; i &lt;= n; i++) &#123;    mp[G[i].size()].insert(i);  &#125;  for (auto [k, v] : mp) &#123;    bfs(v, k);  &#125;  for (int i = 1; i &lt;= n; i++) &#123;    cout &lt;&lt; (dis[i] &gt;= 1e9 ? -1 : dis[i]) &lt;&lt; &#x27; &#x27;;  &#125;  cout &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["训练赛","牛客寒训","构造"]},{"title":"你好世界!","url":"/2026/01/18/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/","content":"\n本博客建立于2026年1月18日\n我也还没想好写什么\n只是刷题缺少一个放题解的地方\n…\n\n"},{"title":"训练赛-AT-ABC442","url":"/2026/01/25/%E8%AE%AD%E7%BB%83%E8%B5%9B-AT-ABC442/","content":"题目链接\n A. Count\n\n白给签到题\n\n B. Music Player\n\n还是白给签到题\n\n C. Peer Review\n 题意\n\nn个人,m对冲突关系,具有冲突关系的人不能相互评阅\n每次评阅需要3个人\n求解每个人可能的评论者的三元组数量\n\n 思路\n\n简单计数\n记录总人数,和每个人的冲突人数\n对每个人计算C总人数−13C_{总人数-1}^{3}C总人数−13​\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n, m;  cin &gt;&gt; n &gt;&gt; m;  unordered_map&lt;ll, ll&gt; mp;  for (int i = 1; i &lt;= m; i++) &#123;    int a, b;    cin &gt;&gt; a &gt;&gt; b;    mp[a]++;    mp[b]++;  &#125;  for (int i = 1; i &lt;= n; i++) &#123;    ll x = n - mp[i] - 1;    if (x &lt; 3)      cout &lt;&lt; 0 &lt;&lt; &#x27; &#x27;;    else      cout &lt;&lt; x * (x - 1) * (x - 2) / 6 &lt;&lt; &#x27; &#x27;;  &#125;  cout &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n D. Swap and Range Sum\n 题意\n\n给定长为n的序列,处理q次查询\n查询有两种类型:\n\n1 x:交换AxA_xAx​和Ax+1A_{x+1}Ax+1​\n2 l r:查询∑i=lrAi\\sum_{i=l}^{r}A_i∑i=lr​Ai​\n\n\n\n 思路\n\n观察发现交换操作只影响sum[x]sum[x]sum[x]\n维护前缀和数组,每次定点修改即可\n修改和查询复杂度都是O(1)O(1)O(1)\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n, q;  cin &gt;&gt; n &gt;&gt; q;  vector&lt;ll&gt; a(n + 10), sum(n + 10, 0);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];    sum[i] = sum[i - 1] + a[i];  &#125;  for (int i = 1; i &lt;= q; i++) &#123;    int op;    cin &gt;&gt; op;    if (op == 1) &#123;      int x;      cin &gt;&gt; x;      sum[x] += a[x + 1] - a[x];      swap(a[x + 1], a[x]);    &#125; else &#123;      int l, r;      cin &gt;&gt; l &gt;&gt; r;      cout &lt;&lt; sum[r] - sum[l - 1] &lt;&lt; endl;    &#125;  &#125;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n E. Laser Takahashi\n 题意\n\n平面上n个点,处理q次询问\n每次询问给出i,j\n输出从AiA_iAi​顺时针旋转到AjA_jAj​的过程中能覆盖的点数\n1&lt;=n,q&lt;=2e5\n\n 思路\n\n某种程度上讲还是前缀和,只是按角度维护\n库函数atan2(y,x)传入坐标返回弧度值,范围在(−π,π](-\\pi,\\pi](−π,π]\n把每个点的弧度值记下来,升序排个序\n此时[A,B]顺时针的个数&lt;=&gt;[B,A]逆时针的个数\nupper_bound查找右界,lower_bound查找左界,两者相减就是个数\n特别的如果B&gt;A,那么个数就是n-(cntb-cnta)\n补充:\n\n如果用角度做的话对精度的处理很麻烦,必须使用long double\n更好的做法是用叉积来做极坐标排序\n\n划定两个半平面[0,π)[0,\\pi)[0,π)和[π,2π)[\\pi,2\\pi)[π,2π),直接升序排序  struct point &#123;    int x, y;&#125;;long long cross(const point &amp;a, const point &amp;b) &#123;    return (long long) a.x * b.y - (long long) a.y * b.x;&#125;bool cmp(const point &amp;a, const point &amp;b) &#123;    int ah = (a.y &lt; 0 or (a.y == 0 and a.x &lt; 0));    int bh = (b.y &lt; 0 or (b.y == 0 and b.x &lt; 0));    if (ah != bh) return ah &lt; bh;    return cross(a, b) &gt; 0;&#125;void argument_sort(vector&lt;point&gt; &amp;points) &#123;    sort(points.begin(), points.end(), cmp);&#125;\n\n\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;#define pll pair&lt;long long, long long&gt;using namespace std;using ll = long long;#define double long doubleconst double eps = 1e-9;void solve() &#123;  int n, q;  cin &gt;&gt; n &gt;&gt; q;  vector&lt;double&gt; b(n + 1);  vector&lt;double&gt; c(n + 1);  for (int i = 1; i &lt;= n; i++) &#123;    long long x, y;    cin &gt;&gt; x &gt;&gt; y;    b[i] = c[i] = atan2l(y, x);  &#125;  sort(b.begin() + 1, b.begin() + n + 1);  for (int i = 0; i &lt; q; i++) &#123;    int x, y;    cin &gt;&gt; x &gt;&gt; y;    double angA = c[x];    double angB = c[y];    ll cntA = upper_bound(b.begin() + 1, b.end(), angA) - b.begin();    ll cntB = lower_bound(b.begin() + 1, b.end(), angB) - b.begin();    //    cout &lt;&lt; cntA &lt;&lt; &#x27; &#x27; &lt;&lt; cntB &lt;&lt; endl;    if (angB &lt;= angA)      cout &lt;&lt; cntA - cntB &lt;&lt; endl;    else      cout &lt;&lt; n - cntB + cntA &lt;&lt; endl;  &#125;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["训练赛","ATcoder","极坐标"]},{"title":"训练赛-26牛客寒假(I)","url":"/2026/02/04/%E8%AE%AD%E7%BB%83%E8%B5%9B-26%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87-I/","content":"比赛链接\n\n第一场,A题大模拟发病写了半天\n2026.2.8补完所有题,牢\n\n L\n 题意\n\n给定一个正整数nnn,可以进行一次操作使n=n∗xn=n*xn=n∗x\n找出最小的正整数xxx使得n mod x=0n\\text{ mod }x=0n mod x=0\n\n 思路\n\n签到题\n显然的,10以内xxx一定有解\n直接枚举即可\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  for (int i = 1; i &lt;= 10; i++) &#123;    if (n * i % 10 == 0) &#123;      cout &lt;&lt; i &lt;&lt; endl;      return;    &#125;  &#125;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n C\n 题意\n\n给定长度为nnn的数组,希望数组的总和尽量的大,可以进行任意次下列操作:\n\n选定任何一对下标l,rl,rl,r,将区间(l,r)(l,r)(l,r)内的所有数变为max(al,ar)max(a_l,a_r)max(al​,ar​)\n\n\n求出数组总和的最大值\n\n 思路\n\n签到题\n观察发现,除了两个端点a1,ana_1,a_na1​,an​,剩下的都可以变成整个数组的最大值\n直接计算即可\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;ll&gt; a(n + 10);  ll mx = -1;  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];    mx = max(mx, a[i]);  &#125;  if (n == 1)    cout &lt;&lt; a[1] &lt;&lt; endl;  else if (n == 2)    cout &lt;&lt; a[1] + a[2] &lt;&lt; endl;  else    cout &lt;&lt; a[1] + a[n] + (n - 2) * mx &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n K\n 题意\n\n给定正整数nnn,构造一个长为nnn的数组,满足以下条件\n\n数组中所有元素是正整数\n所有元素的乘积等于所有元素的和\n数组中的元素两两不同\n\n\n若存在,输出字典序最小的解,否则报告无解\n\n 思路\n\n简单构造\n手玩一下发现,只有n=1 or n=3n=1\\text{ or } n=3n=1 or n=3成立\n剩下的情况乘积远超过求和,显然不成立\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  if (n == 1) &#123;    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;    cout &lt;&lt; 1 &lt;&lt; endl;  &#125; else if (n == 3) &#123;    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;1 2 3&quot; &lt;&lt; endl;  &#125; else &#123;    cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;  &#125;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;   cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n E\n 题意\n\n有nnn个方块,每个方块上有一个数字aia_iai​,此外还有一个写着数字kkk的万能方块\n每次可以把万能方块放在最左侧,挤掉最右侧的方块ana_nan​\n你可以进行任意次操作,求解操作若干次后,将从左往右第一个方块上的数字加上最终万能方块上的数字的和的最大值\n\n 思路\n\n观察发现,最终所求的东西就是把万能方块放在开头后,整个数组中最大相邻对的和\n涉及环的问题,可以考虑对idx取模或者把数组double\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n, k;  cin &gt;&gt; n &gt;&gt; k;  vector&lt;ll&gt; a(2 * n + 10);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];    a[i + n + 1] = a[i];  &#125;  a[n + 1] = k;  ll ans = LLONG_MIN;  for (int i = 1; i &lt;= 2 * n; i++) &#123;    ans = max(ans, a[i] + a[i + 1]);  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n B\n 题意\n\n两个人玩卡牌游戏,每个人手中有nnn张牌,所有牌的数字恰好构成一个长为2n2n2n的排列\n游戏规则如下\n\n如果一个人手中没有牌了,游戏结束\n比较两个人手牌中最前一张,数字大的一方获得一分并移除该张牌,另一方不得分\n\n\n在开始前,你可以任意的改变你的手牌顺序,求出有多少种排列能使你获得最大分数\n答案对998244353取模\n\n 思路\n\n观察发现,对于自己手中的牌,可以分为两类:能得分的,不能得分的\n只要点数比对面最小的牌大就一定有得分机会\n能得分的牌想得分就一定要放到不能得分的牌前面\n所以整个数组分为两部分能得分的∣不能得分的{\\text{能得分的}|\\text{不能得分的}}能得分的∣不能得分的,在这两部分内部,数字可以任意排列\nans=Acnt能得分cnt能得分⋅Acnt不能得分cnt不能得分ans=A_{cnt_{能得分}}^{cnt_{能得分}} \\cdot A_{cnt_{不能得分}}^{cnt_{不能得分}}ans=Acnt能得分​cnt能得分​​⋅Acnt不能得分​cnt不能得分​​\n排个序,随便搞一下就行\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const ll p = 998244353;ll fac[1010101];void init() &#123;  fac[0] = 1;  for (int i = 1; i &lt; 1010101; i++) &#123;    fac[i] = fac[i - 1] * i % p;  &#125;&#125;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;ll&gt; a(n + 10), b(n + 10);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  ll minb = LLONG_MAX;  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; b[i];    minb = min(minb, b[i]);  &#125;  sort(a.begin() + 1, a.begin() + n + 1);  ll cnt = upper_bound(a.begin() + 1, a.begin() + n + 1, minb) - a.begin();  cnt--;  cout &lt;&lt; fac[cnt] * fac[n - cnt] % p &lt;&lt; endl;&#125;int main() &#123;  init();  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n A\n\n 题意\n\n你有8个数字显示器,每个显示器由7个灯管组成\n所有显示器第iii个灯管正常显示的概率是ai%a_i\\%ai​%\n给定一个整数CCC,求解出现下述事件的概率\n\n所有显示器都有灯管被点亮\n所有显示器结果均为合法数字\n前四个显示器组合到一起的数字记为AAA,后四位组成的数字记为BBB,A+B=CA+B=CA+B=C\n\n\n对于结果,输出ans mod 998244353ans \\text{ mod } 998244353ans mod 998244353后的结果\n0&lt;=C&lt;=20260&lt;=C&lt;=20260&lt;=C&lt;=2026\n\n 思路\n\n全场唯一真史,纯恶心\n预处理每个数字出现的概率,然后枚举i+j=Ci+j=Ci+j=C,求和\n最后处理一下分母逆元\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const ll mod = 998244353;vector&lt;ll&gt; p(10);vector&lt;ll&gt; a(10);vector&lt;ll&gt; b(10);ll qpow(ll a, ll b) &#123;  a = a % mod;  ll ans = 1;  while (b) &#123;    if (b &amp; 1)      ans = ans * a % mod;    a = a * a % mod;    b &gt;&gt;= 1;  &#125;  return ans;&#125;ll inv(ll x) &#123; return qpow(x, mod - 2); &#125;void calc() &#123;  p[0] = a[1] * a[2] * a[3] * b[4] * a[5] * a[6] * a[7] % mod;  p[1] = b[1] * b[2] * a[3] * b[4] * b[5] * a[6] * b[7] % mod;  p[2] = a[1] * b[2] * a[3] * a[4] * a[5] * b[6] * a[7] % mod;  p[3] = a[1] * b[2] * a[3] * a[4] * b[5] * a[6] * a[7] % mod;  p[4] = b[1] * a[2] * a[3] * a[4] * b[5] * a[6] * b[7] % mod;  p[5] = a[1] * a[2] * b[3] * a[4] * b[5] * a[6] * a[7] % mod;  p[6] = a[1] * a[2] * b[3] * a[4] * a[5] * a[6] * a[7] % mod;  p[7] = a[1] * b[2] * a[3] * b[4] * b[5] * a[6] * b[7] % mod;  p[8] = a[1] * a[2] * a[3] * a[4] * a[5] * a[6] * a[7] % mod;  p[9] = a[1] * a[2] * a[3] * a[4] * b[5] * a[6] * a[7] % mod;&#125;void solve() &#123;  int c;  cin &gt;&gt; c;  for (int i = 1; i &lt;= 7; i++) &#123;    cin &gt;&gt; a[i];    b[i] = 100 - a[i];  &#125;  calc();  ll ansu = 0, ansd = 1;  for (int i = 0; i &lt;= c; i++) &#123;    int tpa = i, tpb = c - i;    ansu = (ansu + p[tpa / 1000] * p[tpa % 1000 / 100] % mod *                       p[tpa % 100 / 10] % mod * p[tpa % 10] % mod *                       p[tpb / 1000] % mod * p[tpb % 1000 / 100] % mod *                       p[tpb % 100 / 10] % mod * p[tpb % 10] % mod) %           mod;  &#125;  ansd = qpow((ll)1e14, 8);  cout &lt;&lt; ansu * inv(ansd) % mod &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n G\n 题意\n\n多测\n给定区间 [l,r][l,r][l,r], (1≤l≤r≤1015)(1 \\leq l \\leq r \\leq 10^{15})(1≤l≤r≤1015), 定义 f(x)f(x)f(x) 为把数字 xxx 的+进制翻转后去除前导 0 的值\n求区间中所有数字 iii (l≤i≤r)(l \\leq i \\leq r)(l≤i≤r) 的 f(i)f(i)f(i) 最大值\n\n 思路\n\n写的比较匆忙,乱搞的,重新整理了一下思路\n贪心+暴力枚举\n因为希望最大,所以总希望在最低位置9,这样反转以后高位就大\n置9会面临两个问题:(1)放置完后的串会不会超范围?(2)怎么放能获得最大的值?\n\n对于第一个问题:如果这一位本来是9,没有影响,如果这一位不是9,需要向前借位,按位放置,一共不超过15位,可以每次都检查\n对于第二个问题:具体的放置方法是不确定的和l,rl,rl,r的取值有关,所以每次产出一个数都尝试更新一下ans\n\n\n具体操作上\n\n用字符串读入l,rl,rl,r\nans的初始值要设置为reverse(r)\n然后在rrr上开始操作,每次置位后检查是否在合法范围内\n注意:借位的过程中可能导致前导0的出现,需要去除\n如果合法更新ans\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  string l, r;  cin &gt;&gt; l &gt;&gt; r;  string tmpr = r;  reverse(tmpr.begin(), tmpr.end());  ll ans = stoll(tmpr);  tmpr = r;  for (int i = r.size() - 1; i &gt;= 0; i--) &#123;    if (tmpr[i] == &#x27;9&#x27;)      continue;    else &#123;      tmpr[i] = &#x27;9&#x27;;      for (int j = i - 1; j &gt;= 0; j--) &#123;        if (tmpr[j] != 0) &#123;          tmpr[j]--;          break;        &#125; else &#123;          tmpr[j] = &#x27;9&#x27;;        &#125;      &#125;      ll v = stoll(tmpr);      if (v &gt;= stoll(l) &amp;&amp; v &lt;= stoll(r)) &#123;        string tmp = to_string(v);        reverse(tmp.begin(), tmp.end());        ans = max(ans, stoll(tmp));      &#125;    &#125;  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n H\n\n依旧线性DP,依旧坐牢\n划分型dp\n\n 题意\n\n给定一个长为nnn的序列aaa,表示运算式:a1+a2+a3..+ana_1+a_2+a_3..+a_na1​+a2​+a3​..+an​,问有多少种把+替换成|的方式,使得不改变运算式的值(不替换也是一种方案,且特别的:本题中认为|运算优先级大于+)\n\n 思路\n\n妙妙题\n**|运算优先级大于+**意味着可以把数组切分成若干连续|块,块与块之间用加号链接\n然后求解划分的方案数\n对于这类问题通常枚举最后一段的位置,然后计算\n同类典型例题\n\nn个数字之间,加入k个*使得构成的算式值最大\n设dp[i][j]dp[i][j]dp[i][j]表示前iii个数字放了jjj个乘号最大价值\n转移方程dp[i][j]=max(dp[k][j−1])∗[k+1,i]dp[i][j]=max(dp[k][j-1])*[k+1,i]dp[i][j]=max(dp[k][j−1])∗[k+1,i]\n\n\n本题因为没有规定要划分多少段,所以不需要第二维\n定义dp[i]dp[i]dp[i]表示[1,i][1,i][1,i]这个子数组中,替换的合法方案数\n则从iii往前找连续的一段,保证这一段求和的结果和求或的结果一样,记这一段为[j,i][j,i][j,i]\n那么从iii往前最多到jjj都可以成为最后的连续|段,对应的方案数就是dp[j−1]...dp[i−1]dp[j-1]...dp[i-1]dp[j−1]...dp[i−1]\n那么就可以转移dp[i]=∑k=j−1i−1dp[k]dp[i]=\\sum_{k=j-1}^{i-1}dp[k]\ndp[i]=k=j−1∑i−1​dp[k]\n\n用一个前缀和来优化则dp[i]=dps[i−1]−dps[j−2]dp[i]=dps[i-1]-dps[j-2]\ndp[i]=dps[i−1]−dps[j−2]\ndps[i]=dps[i−1]−dp[i]dps[i]=dps[i-1]-dp[i]\ndps[i]=dps[i−1]−dp[i]\n\n对于每一个iii怎么快速的获得jjj的位置?\n\n读入完后跑一遍双指针\n检查sum==sum_or\n\n\n注意初始化,dp[0]=1,dps[0]=1dp[0]=1,dps[0]=1dp[0]=1,dps[0]=1\n\n 补充知识:划分型dp\n\n\n给定一个序列,要求将其切分成若干个连续的子段,使得这些子段满足某些条件,或者让某种总代价（最大值/最小值/计数）达到最优\n\n\n几乎所有的划分型 DP 都遵循同一个套路:枚举最后一段,划分型 DP往往需要用一些手段来优化枚举(前缀和…)\n\n\n状态定义:dp[i]dp[i]dp[i]表示前iii个元素(下标 1…i1 \\dots i1…i)切分完毕后,所能达到的最优解(或方案数)\n\n\n转移方程:\n\n为了算出 dp[i]dp[i]dp[i],我们枚举最后一段的起点（假设最后一段是 j+1j+1j+1 到 iii）\n\ndp[i]=∑0≤j&lt;i(dp[j] ⊕ Cost(j+1,i))dp[i] = \\sum_{0 \\le j &lt; i} \\left( dp[j] \\ \\oplus \\ \\text{Cost}(j+1, i) \\right) \ndp[i]=0≤j&lt;i∑​(dp[j] ⊕ Cost(j+1,i))\n\njjj:枚举的切分点（上一段的结束位置）\ndp[j]dp[j]dp[j]:前 jjj 个已经切好的最优结果\nCost(j+1,i)\\text{Cost}(j+1, i)Cost(j+1,i):最后一段 [j+1,i][j+1, i][j+1,i] 的属性,比如和、最大值、是否合法等,注意是(j+1)(j+1)(j+1)\n⊕\\oplus⊕:连接操作（如果是求方案数就是 +,求最大值就是 max,求和就是 +）\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int p = 998244353;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;ll&gt; a(n + 10);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  int l = 1, r = 1;  ll sum = 0;  vector&lt;ll&gt; lim(n + 10);  while (l &lt;= r) &#123;    while (r &lt;= n &amp;&amp; sum + a[r] == (sum | a[r])) &#123;      lim[r] = l;      sum += a[r];      r++;    &#125;    sum -= a[l];    l++;  &#125;  vector&lt;ll&gt; dp(n + 10);  vector&lt;ll&gt; dps(n + 10);  dps[0] = dp[0] = 1;  for (int i = 1; i &lt;= n; i++) &#123;    if (lim[i] &gt;= 2)      dp[i] = (dps[i - 1] - dps[lim[i] - 2] + p) % p;    else      dp[i] = dps[i - 1];    dps[i] = (dps[i - 1] + dp[i]) % p;  &#125;  cout &lt;&lt; dp[n] &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n D\n\n也是好题\n\n 题意\n\n给定一个序列,其中有白色数组也有黑色数字,再给定参数k表示一开始可以选择k个白数字染红\n接下来每秒都会发生:所有红色数字都会把其右侧aia_iai​,个数字里的白色数字染红\n求：以最优策略染红最初的k个白色数字的话,所有白色数字都会被染红的最短时间\n(注意：黑色数字不会、也无需被染红)\n\n 思路\n\n显然,答案具有单调性,超过某一个时间后都是合格的,在这个时间之前都是不合格的\n考虑二分,二分最终状态不合格...r|l...合格的,答案就是二分的lll\n对时间进行二分,写check检验当前时间下填满需要多少次,用次数和k比较\n怎么检验\n\n贪心的角度考虑,第一个白色是一定要染的,否则就永远无法它\n染色完第一个后,就看第一个能传播多少,等传播够对应的秒或者传播不动了就染下一个\n重复这个过程\n\n\n如何快速的获得aia_iai​最远传播到多少\n\n对于每个白点,染色它能传播到的最远距离是ai+ia_i+iai​+i\n所以,对于第iii个位置,能到达的最远距离其实就是对a_j+j \\, (j\\leqi)做前缀最大\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;#define endl &#x27;\\n&#x27;using namespace std;using ll = long long;int a[505050], nxt[505050];int n, k;// 二分的最终状态:不合法的.....r|l...合法的bool check(int x) &#123;  int ans = 0;  int tim = 0;  for (int i = 1; i &lt;= n;) &#123;    // 跳过黑色    while (a[i] == 0 &amp;&amp; i &lt;= n)      i++;    if (i &gt; n)      break;    // 处理现在面前的    while (tim != x &amp;&amp; nxt[i] != i &amp;&amp; i &lt;= n) &#123;      tim++;      i = nxt[i];    &#125;    // 准备处理下一个    i++;    tim = 0;    ans++;  &#125;  return ans &lt;= k;&#125;void solve() &#123;  cin &gt;&gt; n &gt;&gt; k;  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];    nxt[i] = max(nxt[i - 1], a[i] + i);  &#125;  int l = 0, r = n;  while (l &lt;= r) &#123;    int mid = (l + r) &gt;&gt; 1;    if (check(mid)) &#123;      r = mid - 1;    &#125; else &#123;      l = mid + 1;    &#125;  &#125;  cout &lt;&lt; (l &gt; n ? -1 : l) &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n I\n\n神秘构造,能构出来的真牛逼\n\n 题意\n\n给定一个区间[l,r][l,r][l,r],可以进行如下操作任意次\n选取区间中若干个数字(至少一个),将他们的按位与加入集合SSS\n求:SSS的mex最大是多少\nmex:未出现在集合中的最小非负整数\n\n 思路\n\n情况1:注意到如果l==0l==0l==0,那么所有小于rrr的数都可以通过只选取一个数构造出来,而由于与运算只会变小,所以大于rrr的数一定无法构造出来,答案是r+1r+1r+1\n情况2:注意到如果l,rl,rl,r最高位相同,那么区间中的任何数做与,最高位都一定是1,0无法被构造出来,答案是0\n情况3:继续按照最高位考虑,记b1,b2b_1,b_2b1​,b2​为l,rl,rl,r的位数,如果b2−b1&gt;=2b_2-b_1&gt;=2b2​−b1​&gt;=2,那么100...000和001...111两个数一定在区间内,用前者到后者之间的每一个数和后者做与,就能够造出001...111 0001...111~0001...111 0,所以这种情况下答案也是r+1r+1r+1\n情况4:\n\n如果b2−b1==1b_2-b_1==1b2​−b1​==1,那么10...0~r和01...1做与可以得到r−2b2 0r-2^{b_2}~0r−2b2​ 0,也就是答案至少是r−2b2+1r-2^{b_2}+1r−2b2​+1\n注意到,lll本身是可以向下延伸的,一定可以延伸到从高往低数,第一个0后全填充0的状态\n因为从第一个0后,全是1的数到全是0的数一定存在,把第一个0改成1后面全是0的数也一定存在,两者做与就可以向下拓宽lll\n把算出来的下界,和至少的ans做一下合并就ok了\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;#define endl &#x27;\\n&#x27;using namespace std;using ll = long long;using pii = pair&lt;int, int&gt;;using pll = pair&lt;long long, long long&gt;;ll hibit(ll x) &#123;  ll cnt = 0;  while (x) &#123;    cnt++;    x &gt;&gt;= 1;  &#125;  return cnt;&#125;void solve() &#123;  ll l, r;  cin &gt;&gt; l &gt;&gt; r;  ll b1 = hibit(l), b2 = hibit(r);  if (l == 0)    cout &lt;&lt; r + 1 &lt;&lt; endl;  else if (b1 == b2)    cout &lt;&lt; 0 &lt;&lt; endl;  else if (b2 - b1 &gt;= 2)    cout &lt;&lt; r + 1 &lt;&lt; endl;  else &#123;    ll down = 0;    for (int i = b1 - 1; i &gt;= 0; i--) &#123;      if ((l &gt;&gt; i &amp; 1) == 0)        break;      down |= 1 &lt;&lt; i;    &#125;    ll ans = 1 + r - (1 &lt;&lt; (b2 - 1));    if (ans &gt;= down)      cout &lt;&lt; r + 1  &lt;&lt; endl;    else      cout &lt;&lt; ans &lt;&lt; endl;  &#125;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n F\n 题意\n\n给定mmm条信息,[l,r,k][l,r,k][l,r,k],表示一个排列在[l,r][l,r][l,r]的最大值是kkk\n求长度为nnn且符合所有信息的排列的个数\n\n 思路\n\n注意到两个性质\n\n对于数字kkk,只能放到所有对应区间的交集\n对于数字kkk,所有区间的并集的最大值就是kkk了\n\n\n对于性质2,kkk越小优先级越高,也就是每个位置放的数的上界是其对应的最小的kkk\n相应的,对于数字而言,数值越大的限制越多,因为他不能出击所有比自己小的区间\n所以优先填放数值大的数字\n综上\n\n我们需要先从小到大处理所有区间,获得每个位置可以填的最小上界lim[i]lim[i]lim[i]\n然后,用lim[i]lim[i]lim[i]维护维护每个值xxx的并集位置G[x]G[x]G[x]\n最后从大到小枚举每个值可能出现的位置,检查在交集中的个数cntcntcnt,ans∗=cntans*=cntans∗=cnt\n注意,还要同步维护一个spacespacespace,表示没有任何限制的位置的个数,每次确定一个数后,它剩余的可能位置就被释放,要加给spacespacespace\n\n\n复杂度瓶颈在于第一步,如果暴力的做有可能退化到O(qn)O(qn)O(qn)\n\n我们希望每个位置被最小值覆盖后就不再被访问\n从小到大枚举区间\n维护一个类似nxtnxtnxt的东西,只要被覆盖了就给覆盖区间内所有位置的nxtnxtnxt标记为区间右界\n维护一个并查集,最开始fafafa是自己,一旦访问就改变,fa[i]=find(i+1)fa[i]=find(i+1)fa[i]=find(i+1),这样子通过路径压缩就可以保证整个区间的点都会指向区间右界\n然后维护的时候就可以跳跃访问,每次从i-&gt;fa[i]\n复杂度O(n)O(n)O(n)\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;#define endl &#x27;\\n&#x27;using ll = long long;using pii = pair&lt;int, int&gt;;using pll = pair&lt;long long, long long&gt;;const int p = 998244353;int n, m;int fa[2020202];bool cmp(array&lt;int, 3&gt; x, array&lt;int, 3&gt; y) &#123; return x[2] &lt; y[2]; &#125;int find(int x) &#123; return x == fa[x] ? x : fa[x] = find(fa[x]); &#125;void solve() &#123;  cin &gt;&gt; n &gt;&gt; m;  vector&lt;array&lt;int, 3&gt;&gt; a(m + 1);  for (int i = 1; i &lt;= m; i++) &#123;    auto &amp;[l, r, k] = a[i];    cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;  &#125;  sort(a.begin() + 1, a.end(), cmp);  for (int i = 1; i &lt;= n + 1; i++)    fa[i] = i;  vector&lt;int&gt; lim(n + 1, n);  vector&lt;int&gt; L(n + 1, 1), R(n + 1, n);  vector&lt;set&lt;int&gt;&gt; b(n + 1);  for (int i = 1; i &lt;= m; i++) &#123;    auto [l, r, k] = a[i];    for (int j = find(l); j &lt;= r; j = fa[j]) &#123;      fa[j] = find(j + 1);      lim[j] = k;    &#125;    L[k] = max(L[k], l);    R[k] = min(R[k], r);  &#125;  for (int i = 1; i &lt;= n; i++) &#123;    // cout &lt;&lt; &quot;&gt;&gt;&gt;&quot; &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; lim[i] &lt;&lt; endl;    b[lim[i]].insert(i);  &#125;  ll ans = 1;  ll space = 0;  for (int i = n; i &gt;= 1; i--) &#123;    space += b[i].size();    // cout &lt;&lt; ans &lt;&lt; &#x27; &#x27; &lt;&lt; space &lt;&lt; endl;    if (R[i] &lt; L[i]) &#123;      cout &lt;&lt; 0 &lt;&lt; endl;      return;    &#125;    if (b[i].empty()) &#123;      ans = ans * space % p;    &#125; else &#123;      int cnt = 0      for (auto x : b[i]) &#123;        if (x &lt;= R[i] &amp;&amp; x &gt;= L[i]) &#123;          cnt++;        &#125;      &#125;      ans = ans * cnt % p;    &#125;    space--;  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n J\n\n妙妙题,线段树优化prim,或者使用神秘Boruvka\n\n 题意\n\nnnn点的无向完全图,每个点有数字aia_iai​,其中u,vu,vu,v之间连边的权值为au+ava_u+a_vau​+av​\n删除图中给定的mmm条边后,求图的最小生成树权重,无解输出−1-1−1\n\n 思路\n\n边很多,kruskal肯定不可以\n考虑prim,维护当前MST,每次找从MST中伸出的边的最小值,以及其对应点(查询全局最小)\n将对应点加入MST,更新这个点伸出去的所有边,不能一条一条更新O(n)O(n)O(n),需要一次性更新多条边(区间修改)\n考虑线段树\n用线段树维护所有不在MST中的点\n\n维护当前区间最短边(结果),当前区间最短边对应的编号(用来删除)\n维护当前区间权值最小点(用来更新结果和处理删除),当前区间权值最小点对应的编号(用来维护最短边的编号)\n维护当前区间到MST的最短距离(更新结果)\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;#define endl &#x27;\\n&#x27;using ll = long long;using pii = pair&lt;int, int&gt;;using pll = pair&lt;long long, long long&gt;;const int N = 3e5 + 10;const ll inf = 1e18;struct T &#123;  ll val;  pll edge, vertix;&#125; t[4 * N];vector&lt;ll&gt; a(N);void pushup(int p) &#123;  t[p].vertix = min(t[p * 2].vertix, t[p * 2 + 1].vertix);  t[p].edge = min(t[p * 2].edge, t[p * 2 + 1].edge);&#125;void pushdown(int p) &#123;  if (t[p].val &lt; t[p * 2].val) &#123;    t[p * 2].val = t[p].val;    t[p * 2].edge = min(t[p * 2].edge, &#123;t[p * 2].vertix.first + t[p].val,                                        t[p * 2].vertix.second&#125;);  &#125;  if (t[p].val &lt; t[p * 2 + 1].val) &#123;    t[p * 2 + 1].val = t[p].val;    t[p * 2 + 1].edge =        min(t[p * 2 + 1].edge,            &#123;t[p * 2 + 1].vertix.first + t[p].val, t[p * 2 + 1].vertix.second&#125;);  &#125;  t[p].val = inf;&#125;void build(int p, int l, int r) &#123;  t[p].val = inf;  if (l == r) &#123;    t[p].val = inf;    t[p].vertix = &#123;a[l], l&#125;;    t[p].edge = &#123;a[l] + inf, l&#125;;    return;  &#125;  int mid = (r + l) &gt;&gt; 1;  build(2 * p, l, mid);  build(2 * p + 1, mid + 1, r);  pushup(p);&#125;void del(int p, int l, int r, int x) &#123;  if (l == r) &#123;    t[p].vertix = &#123;inf, l&#125;;    t[p].edge = &#123;inf, l&#125;;    t[p].val = inf;    return;  &#125;  if (t[p].val != inf)    pushdown(p);  int mid = (l + r) &gt;&gt; 1;  if (x &lt;= mid)    del(p * 2, l, mid, x);  else    del(p * 2 + 1, mid + 1, r, x);  pushup(p);&#125;void upd(int p, int l, int r, int x, int y, ll nval) &#123;  if (x &lt;= l &amp;&amp; r &lt;= y) &#123;    t[p].val = min(t[p].val, nval);    t[p].edge = min(t[p].edge, &#123;t[p].vertix.first + nval, t[p].vertix.second&#125;);    return;  &#125;  if (t[p].val != inf)    pushdown(p);  int mid = (r + l) &gt;&gt; 1;  if (x &lt;= mid)    upd(p * 2, l, mid, x, y, nval);  if (y &gt; mid)    upd(p * 2 + 1, mid + 1, r, x, y, nval);  pushup(p);&#125;void solve() &#123;  int n, m;  cin &gt;&gt; n &gt;&gt; m;  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  vector&lt;set&lt;int&gt;&gt; fbd(n + 1);  for (int i = 1; i &lt;= m; i++) &#123;    int u, v;    cin &gt;&gt; u &gt;&gt; v;    fbd[u].insert(v);    fbd[v].insert(u);  &#125;  vector&lt;vector&lt;int&gt;&gt; bad(n + 1);  for (int i = 1; i &lt;= n; i++) &#123;    fbd[i].insert(i);    for (auto _ : fbd[i]) &#123;      bad[i].push_back(_);    &#125;  &#125;  build(1, 1, n);  ll ans = 0;  int idx = 1;  for (int i = 0; i &lt; n - 1; i++) &#123;    del(1, 1, n, idx);    int l = 0;    for (auto r : bad[idx]) &#123;      if (l + 1 &lt;= r - 1)        upd(1, 1, n, l + 1, r - 1, a[idx]);      l = r;    &#125;    if (l &lt; n) &#123;      upd(1, 1, n, l + 1, n, a[idx]);    &#125;    ans += t[1].edge.first;    if (ans &gt;= inf) &#123;      cout &lt;&lt; -1 &lt;&lt; endl;      return;    &#125;    idx = t[1].edge.second;  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["训练赛","牛客寒训","线性dp","划分型dp","二分答案","并查集","数据结构优化prim","妙妙题"]},{"title":"板子-计算几何","url":"/2026/01/23/%E6%9D%BF%E5%AD%90-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/","content":"const double eps = 1e-8; // 精度误差允许范围const double PI = acos(-1.0);// 符号函数：用来处理精度问题int dcmp(double x) &#123;    if (fabs(x) &lt; eps) return 0;    return x &lt; 0 ? -1 : 1;&#125;struct Point &#123;    double x, y;    Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;    Point operator + (const Point&amp; B) const &#123; return Point(x + B.x, y + B.y); &#125;    Point operator - (const Point&amp; B) const &#123; return Point(x - B.x, y - B.y); &#125;    Point operator * (double k) const &#123; return Point(x * k, y * k); &#125;    Point operator / (double k) const &#123; return Point(x / k, y / k); &#125;    // 判等 (精度敏感)    bool operator == (const Point&amp; B) const &#123;        return dcmp(x - B.x) == 0 &amp;&amp; dcmp(y - B.y) == 0;    &#125;&#125;;typedef Point Vector; //点积double Dot(Vector A, Vector B) &#123;    return A.x * B.x + A.y * B.y;&#125;//叉积double Cross(Vector A, Vector B) &#123;    return A.x * B.y - A.y * B.x;&#125;//模double Length(Vector A) &#123;    return sqrt(Dot(A, A));&#125;//模方double Length2(Vector A) &#123;    return Dot(A, A);&#125;//夹角(弧度)double Angle(Vector A, Vector B) &#123;    return acos(Dot(A, B) / Length(A) / Length(B));&#125;// 将向量 A 逆时针旋转 rad 弧度Vector Rotate(Vector A, double rad) &#123;    return Vector(A.x * cos(rad) - A.y * sin(rad), A.x * sin(rad) + A.y * cos(rad));&#125;","categories":["算法竞赛"],"tags":["板子"]},{"title":"训练赛-NK-Week-R127","url":"/2026/01/19/%E8%AE%AD%E7%BB%83%E8%B5%9B-NK-Week-R127/","content":"题目链接\n A\n\n签到题,白给\n\n B\n\n小模拟\n\n 题意\n\n给定4*4数组,用1,2,3,4填充\n检查是否每行,每列,每块(2*2子数组(左上,左下,右上,右下))都有1,2,3,4\n\n 思路\n\n标记数组硬搞就行,但是每块的判断比较麻烦,有两种思路\n\n思路一:枚举四个块的左下角,记为(x,y),那么对于每个左下角,还需检查(x-1,y),(x,y-1),(x-1,y-1)即可\n思路二:0-base数组,坐标到块号的转移是(x/2)*2+(y/2)\n\n\n最后检查的时候注意检查的是1~4,而不是0~3\n\n 代码\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int t;    cin &gt;&gt; t;    int a[5][5];    while(t--)&#123;        bool hang[5][5],lie[5][5],kuai[5][5];        for(int i=0;i&lt;4;i++)&#123;            for(int j=1;j&lt;=4;j++)&#123;                hang[i][j]=lie[i][j]=kuai[i][j]=false;            &#125;        &#125;        for(int i=0;i&lt;4;i++)&#123;            for(int j=0;j&lt;4;j++)&#123;                cin &gt;&gt; a[i][j];                hang[i][a[i][j]]=true;                lie[j][a[i][j]]=true;                kuai[(i/2)*2+(j/2)][a[i][j]]=true;            &#125;        &#125;        bool ok=true;        for(int i=0;i&lt;4;i++)&#123;            for(int j=1;j&lt;=4;j++)&#123;                if(!hang[i][j]||!lie[i][j]||!kuai[i][j]) &#123;                    ok=false;                &#125;            &#125;        &#125;        cout &lt;&lt; (ok?&quot;YES&quot;:&quot;NO&quot;) &lt;&lt; endl;    &#125;&#125;\n C\n\n白给小模拟\n\n D\n\n简单组合数学+递推\n\n 题意\n\n给定一个序列,求其中的双排列子数组的个数\n\n 思路\n\n搞一个map,统计每个数出现的次数\n搞一个计数数组f,f[i]表示长度为i的双排列的个数\n\nf[i]=f[i−1]∗Ccnt[i]2f[i]=f[i-1]*C_{cnt[i]}^{2}f[i]=f[i−1]∗Ccnt[i]2​\n如果cnt[i]&lt;=2就停止\n\n\n最后总次数就是对f做累加即可\n\n 代码\n#include&lt;bits/stdc++.h&gt;using namespace std;long long cnt[202020];const int p=998244353;void solve()&#123;    int n;    cin &gt;&gt; n;    map&lt;long long,long long&gt; mp;    mp.clear();    cnt[0]=1;    for(int i=1;i&lt;=n;i++)&#123;        int x;        cin &gt;&gt; x;        mp[x]++;        cnt[i]=0;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        if(mp[i]&lt;=1) break;        cnt[i]=(cnt[i-1]*mp[i]*(mp[i]-1)/2)%p;        // cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; mp[i] &lt;&lt;&#x27; &#x27; &lt;&lt; cnt[i] &lt;&lt; endl;    &#125;    long long ans=0;    for(int i=1;i&lt;=n;i++)&#123;        ans=(ans+cnt[i])%p;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;\n E\n\n方案数dp or 思维\n\n 题意\n\nT组\n给定一个由0,1,?组成的字符串s,定义s是平衡的当且仅当s中相邻相同对数为偶数,你可以将?替换成0或1使得s变平衡\n求解s可能变成的平衡串个数\n\n 思路\n\n有脑做法:\n\ncnt相同=cnt总对数−cnt不同cnt_{相同}=cnt_{总对数}-cnt_{不同}cnt相同​=cnt总对数​−cnt不同​\ncnt不同的奇偶性=⊕i=1n−1(cnti⊕cnti+1)cnt_{不同}的奇偶性=\\oplus_{i=1}^{n-1}(cnt_{i} \\oplus cnt_{i+1})cnt不同​的奇偶性=⊕i=1n−1​(cnti​⊕cnti+1​)\n右式=cnt1⊕cnt2⊕cnt2⊕cnt3...=cnt1⊕cntn右式=cnt_{1} \\oplus cnt_{2} \\oplus cnt_{2} \\oplus cnt_{3}...=cnt_{1} \\oplus cnt_{n}右式=cnt1​⊕cnt2​⊕cnt2​⊕cnt3​...=cnt1​⊕cntn​\ncnt相同=n−1的奇偶性−cnt1⊕cntn的奇偶性cnt_{相同}=n-1的奇偶性-cnt_1\\oplus cnt_n的奇偶性cnt相同​=n−1的奇偶性−cnt1​⊕cntn​的奇偶性\n分类讨论\n\nn-1为奇数\n\n异或项为奇数-&gt;2cnt[中间的?]2^{cnt[中间的?]}2cnt[中间的?]\n异或项为偶数-&gt;0\n\n\nn-1为偶数\n\n异或项为奇数-&gt;0\n异或项为偶数-&gt;2cnt[中间的?]2^{cnt[中间的?]}2cnt[中间的?]\n\n\n\n\n注意:如果两头都是问号方案数要乘2\n\n\n无脑做法\n\ndp搞一下\ndp的值表示当前位置的方案数\n状态设计:\n\n当前位置的方案数有两种:奇数和偶数\n当前位置的方案数由上一位置的方案数和当前位置的数字决定决定\n所以状态中要包含当前位置的数字和当前是奇数还是偶数\ndp[i][j(1/0)][k(1/0)]dp[i][j(1/0)][k(1/0)]dp[i][j(1/0)][k(1/0)]表示前i个数,第i位填j,相邻相同对是k(奇数还是偶数)\n\n\n直接写就行\n优化:注意到每次转移只和前一位有关,所以可以滚动数组优化空间\n\n\n\n 代码(没写回滚)\n#include&lt;bits/stdc++.h&gt;using namespace std;/** * dp[i][j][k]:到第i个位置,第i个位置是j,前面相同对数是k(0-偶数,1-奇数) * dp[i][j][k]=dp[i-1][j][1-k]+dp[i-1][1-j][k] * 根据a[i]的内容决定更新一个还是两个,不更新的那个置0; * 最后ans=dp[n][0][0]+dp[n][1][0] */const int p=998244353;long long dp[505050][2][2];void solve()&#123;    string s;    cin &gt;&gt; s;        memset(dp,0,sizeof(dp));    if(s[0]==&#x27;0&#x27;||s[0]==&#x27;?&#x27;)dp[0][0][0]=1;    if(s[0]==&#x27;1&#x27;||s[0]==&#x27;?&#x27;)dp[0][1][0]=1;    /**     * 回滚就是维护f[2][2],g[2][2]     * 下面的for循环内每次清空g     * 然后g[][]=f[][]+f[][]     * 最后f=g     * 答案就是f[0][0]+f[1][0]     * */    for(int i=1;i&lt;s.size();i++)&#123;        if(s[i]==&#x27;0&#x27;||s[i]==&#x27;?&#x27;)&#123;            for(int k=0;k&lt;2;k++)&#123;                dp[i][0][k]=(dp[i-1][0][1-k]+dp[i-1][1][k])%p;            &#125;        &#125;        if(s[i]==&#x27;1&#x27;||s[i]==&#x27;?&#x27;)&#123;            for(int k=0;k&lt;2;k++)&#123;                dp[i][1][k]=(dp[i-1][1][1-k]+dp[i-1][0][k])%p;            &#125;        &#125;    &#125;    cout &lt;&lt; (dp[s.size()-1][0][0]+dp[s.size()-1][1][0])%p &lt;&lt; endl;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;\n F\n\nbfs-类似于泛洪问题\n\n 题意\n\n给定一个n*n01矩阵\n对于每个0如果他的上下左右有两个对角相邻的1,那么下一时刻他就变成1\n求矩阵的最终状态\nn&lt;=2000\n\n 思路\n\n正解:\n\n写一个check判断下一时刻会不会变成1\n读入的时候把所有会变成1的0入队,标上vis,改地图\n然后bfs,每次出队的时候判断上下左右的0会不会变成1,会的话入队\n直到队列为空\n\n\n我的思路:\n\n写一个check判断下一时刻会不会变成1\n所有1入队\nbfs,每次出队判断一下周围的0会不会变,如果会变就入队\n直到队列为空\n\n\n\n 代码\n#include&lt;bits/stdc++.h&gt;using namespace std;#define pii pair&lt;int,int&gt;int a[2020][2020];int dir[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;bool check(int x,int y,int tx,int ty)&#123;    if(x!=tx)return (a[tx][ty-1]|a[tx][ty+1]);    else return (a[tx-1][ty]|a[tx+1][ty]);&#125;void solve()&#123;    int n;    cin &gt;&gt; n ;    queue&lt;pii&gt; q;    memset(a,0,sizeof(a));    for(int i=1;i&lt;=n;i++)&#123;        string s;        cin &gt;&gt; s;        for(int j=1;j&lt;=n;j++)&#123;            a[i][j]=s[j-1]-&#x27;0&#x27;;            if(a[i][j]==1) q.push(&#123;i,j&#125;);        &#125;    &#125;    while(!q.empty())&#123;        int nx=q.front().first;        int ny=q.front().second;        q.pop();        for(int i=0;i&lt;4;i++)&#123;            int tx=nx+dir[i][0];            int ty=ny+dir[i][1];            if(a[tx][ty]==1||tx&lt;1||tx&gt;n||ty&lt;1||ty&gt;n) continue;            a[tx][ty]=check(nx,ny,tx,ty);            if(a[tx][ty]==1) q.push(&#123;tx,ty&#125;);        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            cout &lt;&lt; a[i][j];        &#125;        cout &lt;&lt; endl;    &#125;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T--)&#123;        solve();    &#125;    return 0;&#125;","categories":["算法竞赛"],"tags":["训练赛","NK周赛","bfs","方案dp"]},{"title":"训练赛-CF-R1075(div2)","url":"/2026/01/24/%E8%AE%AD%E7%BB%83%E8%B5%9B-CF-R1075-div2/","content":"比赛链接\n\n3/8\n思维感觉完全僵化,没做到算法题\n\n A.Table with Numbers\n 题意\n\n给定一个h*l的表格,每个格子初始为0\n给定一个长为n的数组\n你可以从中不重复的取k个二元组(x,y),如果(x,y)在表格内,就给对应的位置+1\n求解表格中元素和的最大值\n1&lt;=n&lt;=100,1&lt;=h,l&lt;=1000\n\n 思路\n\n其实就是在数组中找范围在h,l之间的数,然后看能构成多少二元组\n读入的时候获得cnt_l,cnt_h表示小于l的个数和小于h的个数\n总保证大的是cnt_h\n如果cnt_h&gt;=2*cnt_l,那么每个小于l的数都可以作为二元组的前键,并且有小于h的数作为后键匹配,所以共能构成cnt_l个二元组\n否则cnt_h&lt;2*cnt_l,那么所有处于[l,h]之间的数可以作为后键,并且有小于l的数作为前键,然后剩余的数依旧可以两两成对,所以共能构成\\floor \\frac{cnt_h}{2} \\floor个二元组\nPS:\n\n卡了半天,没想出来第二种情况搞法,写了一个稍长的式子\n大概思路是:处于[l,h]之间的数可成对,然后用cnt_l减去成对的数量再除二是两两配对\n加和化简后结果是一样的\n\n\n\n 代码\n\n我的解法\n\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n, h, l;  cin &gt;&gt; n &gt;&gt; h &gt;&gt; l;  ll cnt_h = 0, cnt_l = 0;  for (int i = 1; i &lt;= n; i++) &#123;    int tmp;    cin &gt;&gt; tmp;    if (tmp &lt;= h)      cnt_h++;    if (tmp &lt;= l)      cnt_l++;  &#125;  if (cnt_h &lt; cnt_l)    swap(cnt_h, cnt_l);  if (cnt_h &gt;= 2 * cnt_l)    cout &lt;&lt; cnt_l &lt;&lt; endl;  else    cout &lt;&lt; cnt_h - cnt_l + (2 * cnt_l - cnt_h) / 2 &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n\nstd\n\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void solve() &#123;    int n, h, l;    cin &gt;&gt; n &gt;&gt; h &gt;&gt; l;    if (h &gt; l) &#123;        swap(h, l);    &#125;    int x;    int cnth = 0, cntl = 0;        for (int i = 0; i &lt; n; ++i) &#123;        cin &gt;&gt; x;        if (x &lt;= h) &#123;            cnth++;        &#125;        if (x &lt;= l)&#123;            cntl++;        &#125;    &#125;    cout &lt;&lt; min(cnth, cntl / 2)&lt;&lt; &#x27;\\n&#x27;;&#125;signed main() &#123;    ios_base::sync_with_stdio(false);    cin.tie(nullptr);    int tt = 1;    cin &gt;&gt; tt;    while (tt--) &#123;        solve();    &#125;&#125;\n B.The Curse of the Frog\n 题意\n\n数轴0坐标处有一个点,这个点有n种移动方法,这个点需要移动到坐标x处\n每种方法格式为(a,b,c),表示使用该种方法,每次最多可以移动a步,每使用b次,在第b次使用时会先后退c步\n回答最少后退几次就到达x处,如果无法到达输出-1\n\n 思路\n\n神秘英文题面,看半天没看懂样例\n思维过程:\n\n数据范围很大,暴力模拟是不可以的\n对于每种移动,应当考虑其综合价值v=a*b-c\n但是如果直接用x除综合价值计算会有问题\n\nEg:(10,10,99),x=3\n直接用x除综合价值会算出需要回滚3次,但实际上一次都不用\n不能直接除\n\n\n为什么不能直接除,因为有可能回退前的移动已经足够到x\n那如果上来就是回退就可以除\n那就先处理x,让x减去每种移动的最大不回退距离a*(b-1)\n然后用剩余的部分去和综合价值最大的做除,向上取整\n特判x&lt;=0和最大综合价值&lt;0的情况\n\n\n坑:\n\n大数除法向上取整不能用ceil函数,long long转double会丢精度\n正确的向上取整方式:x′+(maxval−1)maxval\\frac{x&#x27;+(maxval-1)}{maxval}\nmaxvalx′+(maxval−1)​\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  ll n, x;  cin &gt;&gt; n &gt;&gt; x;  ll maxval = LLONG_MIN;  for (int i = 1; i &lt;= n; i++) &#123;    ll a, b, c;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    x -= (b - 1) * a;    maxval = max(maxval, b * a - c);  &#125;  if (x &lt;= 0) &#123;    cout &lt;&lt; 0 &lt;&lt; endl;  &#125; else if (maxval &lt;= 0)    cout &lt;&lt; -1 &lt;&lt; endl;  else &#123;    // cout &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; maxval &lt;&lt; endl;    cout &lt;&lt; (x + maxval - 1) / maxval &lt;&lt; endl;  &#125;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n C1.XOR Convenience (Easy Version)\n 题意\n\n构造一个长$$为n的排列,使得任意i(2&lt;=i&lt;=n-1)存在j(i&lt;=j&lt;=n)使得pi=pj⊕ip_i=p_j \\oplus ipi​=pj​⊕i\n\n 思路\n\n对于某一个位置的数,要让他等于该位置的idx和后面一个数的异或\n很容易想到,如果后面这个数是1那么所有奇数i只要放到idx=i-1的位置就行\n同理,所有偶数j需要放到idx=j+1的位置\n最后剩下最大的偶数还没放,正好放在最前面\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  cout &lt;&lt; n / 2 * 2 &lt;&lt; &#x27; &#x27;;  for (int i = 2; i &lt; n; i++) &#123;    if (i % 2)      cout &lt;&lt; i - 1 &lt;&lt; &#x27; &#x27;;    else      cout &lt;&lt; i + 1 &lt;&lt; &#x27; &#x27;;  &#125;  cout &lt;&lt; 1 &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n C2.XOR Convenience (Hard Version)\n 题意\n\n和上一题相同\ni的范围变成1&lt;=i&lt;=n-1\n\n 思路\n\n思维过程\n\n按照上一题的方式构造,那么偶数情况下,第一位的最大偶数就无解\n奇数情况不影响\n认为偶数都不可以交一发,WA了\nGG\n\n\n正解\n\n偶数情况下,2的幂次不可以\n证明:\n\n设n=2kn=2^kn=2k,那么考虑nnn放的位置\n\n如果nnn放在前n−1n-1n−1个位置,那么n⊕i&gt;1n \\oplus i&gt;1n⊕i&gt;1,因为nnn只有高位是1,剩余位是0,所以不成立\n如果nnn放在最后,对于pn−1p_{n-1}pn−1​,需要满足pn−1=(n−1)⊕pnp_{n-1}=(n-1)\\oplus p_npn−1​=(n−1)⊕pn​,右式依旧大于nnn,不成立\n所以2的幂次一定不行\n\n\n\n\n对于其它2的倍数怎么构造?\n\n先按照之前的方法构造\n\nEg.n=6n=6n=6,序列[6,3,2,5,4,1][6,3,2,5,4,1][6,3,2,5,4,1]\n然后,设nnn的二进制最高位数值为rrr,交换p1p_1p1​和pn−rp_{n-r}pn−r​\nn−rn-rn−r是偶数,所以放在该位置的值是n−r+1n-r+1n−r+1\nnnn放过去后一定满足,因为rrr的位置是(r+1)&gt;(n−r)(r+1)&gt;(n-r)(r+1)&gt;(n−r)\n换到开头的值是n−r+1n-r+1n−r+1,后面一定有pj=n−rp_j=n-rpj​=n−r\n\n\n\n\n\n\n还有一种做法\n\nlowbit(n)=llowbit(n)=llowbit(n)=l\nnnn放在plp_lpl​,lll放在p1p_1p1​,111放在pnp_npn​\n\n\n特别的,判断是不是2的幂次,用n&amp;(n-1)==0\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  if ((n &amp; (n - 1)) == 0) &#123;    cout &lt;&lt; -1 &lt;&lt; endl;    return;  &#125;  vector&lt;ll&gt; ans;  ans.push_back(n / 2 * 2);  for (int i = 2; i &lt; n; i++) &#123;    if (i % 2)      ans.push_back(i - 1);    else      ans.push_back(i + 1);  &#125;  ans.push_back(1);  if (n % 2) &#123;    for (auto x : ans) &#123;      cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;    &#125;  &#125; else &#123;    swap(ans[0], ans[n - (1 &lt;&lt; (ll)log2(n)) - 1]);    for (auto x : ans) &#123;      cout &lt;&lt; x &lt;&lt; &#x27; &#x27;;    &#125;  &#125;  cout &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n D1.Little String (Easy Version)\n 题意\n\n给定01字符串s,和整数c\ns中每一位的取值表示了对一个[0,...,n-1]的排列的要求\n\n如果s[i]=′0′s[i]=&#x27;0&#x27;s[i]=′0′,那么排列中不存在子序列sub_p使得mex(sub_p)=i\n如果s[i]=′1′s[i]=&#x27;1&#x27;s[i]=′1′,那么排列中存在子序列sub_p使得mex(sub_p)=i\n\n\n求解满足s限制的排列数,答案对1e9+7取模\n特别地,如果不存在这样的排列或者答案对c取模后为0,输出-1\n\n 思路\n\n分析限制条件发现,1-base存s,则s[i]限制的是排列中i的放置方法\n\n如果s[i]=′1′s[i]=&#x27;1&#x27;s[i]=′1′,那么[0,i-1]这些数必须连续,i的放置位置只能是[0,i-1]的两侧\n反之,如果s[i]=′0′s[i]=&#x27;0&#x27;s[i]=′0′,那么[0,i-1]一定不能连续,i的放置必须打断他们,也就是除了两边,其它都可以放\n特别的,s[1]和s[n]必须为'1',否则无解,并且,递推的时候不用算s[n],因为只放置到n-1\n\n\n递推公式如下ans=∏i=1n−1{2,s[i]=′1′i−1,s[i]=′0′  ans=\\prod_{i=1}^{n-1}\n  \\begin{cases}\n    2, &amp; s[i]=&#x27;1&#x27; \\\\\n    i-1,  &amp; s[i]=&#x27;0&#x27;\n  \\end{cases}\nans=i=1∏n−1​{2,i−1,​s[i]=′1′s[i]=′0′​\n\n最后,需要同时维护两个ans,一个对1e9+7取模,一个对c取模,取模不能叠加\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int p = 1e9 + 7;void solve() &#123;  int n, c;  cin &gt;&gt; n &gt;&gt; c;  string s;  cin &gt;&gt; s;  s = &#x27; &#x27; + s;  ll ans = 1, ansc = 1;  if (s[1] == &#x27;0&#x27; || s[n] == &#x27;0&#x27;) &#123;    cout &lt;&lt; -1 &lt;&lt; endl;    return;  &#125;  for (int i = 1; i &lt;= n - 1; i++) &#123;    if (s[i] == &#x27;1&#x27;) &#123;      ans = ans * 2 % p;      ansc = ansc * 2 % c;    &#125; else &#123;      ans = ans * (i - 1) % p;      ansc = ansc * (i - 1) % c;    &#125;  &#125;  if (ansc == 0)    cout &lt;&lt; -1 &lt;&lt; endl;  else    cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n D2.Little String (Hard Version)\n\n好难,补了快一天:(\n\n 题意\n\n和D1一样,但是,现在你的字符串中会有?,你可以用0/1替换\n你需要找出不被c整除的情况下的最小排列数\n\n 思路\n\nhint1:\n\n构造计数题,最后一定是一个递推的数学公式或者dp\n直接考虑排列很复杂,考虑一个个数往里放,结合mex定义,找出连乘递推式\n\n\nhint2:\n\n?很多,最多有2cnt2^{cnt}2cnt种可能性,不可枚举–贪心\n怎么贪?\n\n观察连乘式的构成\n\ni=2,填0,权值更小\n其他情况,填1,权值更小\n\n\n\n\n理论最小值:s[2]=0,其它?填1\n发现会出问题,理论最小值可能是一个c的倍数–反悔贪心\n\n先处理出理论最小,然后调整,把缺的加回来\n\n\n\n\nhint3:\n\n怎么处理c?\n考虑c和ans的关系\n\nans是一个累乘式,其中一部分是已经确定了的,没确定的部分中有很多2\n2的个数是不确定的\n\n\n\n\nhint4:\n\n直接算乘积可能会溢出,根本来不及modc\n万一要调整,怎么判断调整之后是不是整除?\n整除&lt;=&gt;一个是另一个的因子\n所以最后判整除,等价于预处理的时候,c/=gcd(c,(i-1 or 2))\n如果全判完c=1说明一定是整除的\n如果全判完c有非2的因子,那么?全取2一定不出问题\n如果全判完c==2^k,那么就要调整几个?,让2变少,也就必须保证调整后的i-1是奇数\n如果全调整完还不够就是寄了\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int p = 1e9 + 7;ll gcd(ll a, ll b) &#123;  if (b == 0)    return a;  return (gcd(b, a % b));&#125;void solve() &#123;  ll n, c;  cin &gt;&gt; n &gt;&gt; c;  string s;  cin &gt;&gt; s;  s = &#x27; &#x27; + s;  if (s[1] == &#x27;0&#x27; || s[n] == &#x27;0&#x27;) &#123;    cout &lt;&lt; -1 &lt;&lt; endl;    return;  &#125;  // 预处理s2  if (s[2] == &#x27;?&#x27;)    s[2] = &#x27;0&#x27;;  s[1] = s[n] = &#x27;1&#x27;;  vector&lt;ll&gt; a;  ll cnt = 0;  for (int i = 1; i &lt;= n - 1; i++) &#123;    if (s[i] == &#x27;0&#x27;) &#123;      c /= gcd(c, i - 1);    &#125; else if (s[i] == &#x27;1&#x27;) &#123;      c /= gcd(c, 2ll);    &#125; else &#123;      cnt++;      if ((i - 1) % 2) &#123;        a.push_back(i);      &#125;    &#125;  &#125;  ll cnt_c = (ll)__lg(c);  if ((c &amp; (c - 1)) == 0 &amp;&amp; cnt_c &lt;= cnt) &#123;    for (auto i : a) &#123;      s[i] = &#x27;0&#x27;;      cnt--;      if (cnt &lt; cnt_c)        break;    &#125;    if (cnt &gt;= cnt_c) &#123;      cout &lt;&lt; -1 &lt;&lt; endl;      return;    &#125;  &#125;  ll ans = 1;  for (int i = 1; i &lt;= n - 1; i++) &#123;    if (s[i] == &#x27;0&#x27;)      ans = ans * (i - 1) % p;    else      ans = ans * 2 % p;  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["训练赛","CF","思维","位运算"]},{"title":"笔记-二分答案","url":"/2026/02/04/%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/","content":" 二分答案 (Binary Search for Answer)\n 1. 思想\n将 “求解问题” 转化为 “判定问题”。\n\n求解：直接算出答案是多少（难）。\n判定：给一个值 mid，判断它是否合法（易，通常配合贪心）。\n\n前提：答案必须具有单调性（如果 xxx 合法，那么比 xxx 小/大的数也都合法）。\n 2. 适用场景\n题目中出现以下字眼时，99% 是二分答案：\n\n“使最大值最小”\n“使最小值最大”\n“求满足条件的最小/大值”\n\n 3. 模板 (while(l &lt;= r))\n// 1. 确定二分范围 [L, R]long long l = min_possible, r = max_possible;while (l &lt;= r) &#123;    long long mid = l + (r - l) / 2; // 防溢出写法    if (check(mid)) &#123;        // 2. mid 可行：记录答案/不记录，尝试更好的（贪心）        ans = mid;         // 如果求最小值：r = mid - 1 (往左找)        // 如果求最大值：l = mid + 1 (往右找)    &#125; else &#123;        // 3. mid 不可行：直接舍弃，去另一边找        // 如果求最小值：l = mid + 1        // 如果求最大值：r = mid - 1    &#125;&#125;cout &lt;&lt; ans &lt;&lt; endl;\n 图解\n\nans的可取范围通常如下图所示\n\n…,是,是,是⏟左侧区域∣否,否,否,…⏟右侧区域\\underbrace{\\dots, \\text{是}, \\text{是}, \\text{是}}_{\\text{左侧区域}} \\quad \\mid \\quad \\underbrace{\\text{否}, \\text{否}, \\text{否}, \\dots}_{\\text{右侧区域}} \n左侧区域…,是,是,是​​∣右侧区域否,否,否,…​​\n\n\nwhile(l &lt;= r) 循环，本质上是在不断压缩 l 和 r，试图把那条分界线夹出来。\n\nl ：不断往右挤，试图跨过分界线进入右边。\nr ：不断往左挤，试图跨过分界线进入左边。\n\n\n\n…,是,r⏟左侧最大值∣l,否,…⏟右侧最小值\\underbrace{\\dots, \\text{是}, \\mathbf{r}}_{\\text{左侧最大值}} \\quad \\mid \\quad \\underbrace{\\mathbf{l}, \\text{否}, \\dots}_{\\text{右侧最小值}} \n左侧最大值…,是,r​​∣右侧最小值l,否,…​​\n\n当 while(l &lt;= r) 结束时，条件 l &gt; r 成立。\n此时，l 和 r 的位置关系一定是：l 刚好在 r 的右边一位。即 l = r + 1。\n\nr：停在了左侧（满足条件）区域的最后一个数。\nl：停在了右侧（不满足条件）区域的第一个数。\n\n\n\n 4. check(mid) 函数怎么写？\n\n逻辑：假设答案是 mid，我能不能利用现有的资源/条件达到要求？\n返回值：true (合法/满足条件) / false (不合法)。\n\n","categories":["算法竞赛"],"tags":["笔记"]},{"title":"题解-dd爱探险","url":"/2026/01/25/%E9%A2%98%E8%A7%A3-dd%E7%88%B1%E6%8E%A2%E9%99%A9/","content":"题目链接\n\n太久没写状压了,都没看出来TT\n\n 题意\n\n地图上有n个点,编号为1到n\n给出n*n的矩阵dis,dis[i][j]表示从点i到点j的距离\n特别的,行走过程中可以进行两次特殊的行走\n\n一次使得两点之间距离为0\n一次使得两点之间距离翻倍\n\n\n求使用了两种特殊行走后,走过所有点所需的最小距离\nn&lt;=16\n\n 思路\n\nn的范围说明不是搜索就是状压DP\n走过所有点的路径–哈密顿路径\n最短哈密顿路径的求法是使用状压DP,dp[st][i]表示当前行走状态为st,最后一个经过的点是i的最短距离\n\n状态转移方程为dp[st][i] = min(dp[st][i], dp[st-(1&lt;&lt;(i-1))][j] + dis[j][i])\n\n\n两种特殊的路径是否使用可以额外维护一维来表示\n状态设计为dp[st][i][0/1/2/3]表示当前行走状态为st,最后一个经过的点是i,两种特殊行走的使用状态是0/1/2/3\n然后考虑转移,转移大致分为两种\n\n转移前后并未使用特殊行走,转移方程为dp[st][i][0/1/2/3] = dp[st'][j][0/1/2/3] + dis[j][i]\n转移前后使用了特殊行走,转移方程为dp[st][i][k] = dp[st'][j][k'] + (dis[j][i]*0 or *2)\n\n1:使用了距离0,可能由0转移\n2:使用了距离翻倍,可能由0转移\n3:两种都用了,可能由1或2转移\n\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll dp[1 &lt;&lt; 18][18][4];void solve() &#123;  int n;  cin &gt;&gt; n;  int a[18][18];  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= n; j++) &#123;      cin &gt;&gt; a[i][j];    &#125;  &#125;  // 初始化dp  memset(dp, 0x3f3f3f3f, sizeof(dp));  for (int i = 1; i &lt;= n; i++) &#123;    dp[1 &lt;&lt; (i - 1)][i][0] = 0;  &#125;  for (int st = 1; st &lt; (1 &lt;&lt; n); st++) &#123;    for (int i = 1; i &lt;= n; i++) &#123;      // check status      if (((st &gt;&gt; (i - 1)) &amp; 1) == 0)        continue;      int st_old = st - (1 &lt;&lt; (i - 1));      for (int j = 1; j &lt;= n; j++) &#123;        if (((st_old &gt;&gt; (j - 1)) &amp; 1) == 0)          continue;        for (int k = 0; k &lt; 4; k++) &#123;          dp[st][i][k] = min(dp[st][i][k], dp[st_old][j][k] + a[j][i]);        &#125;        dp[st][i][1] = min(dp[st][i][1], dp[st_old][j][0]);        dp[st][i][2] = min(dp[st][i][2], dp[st_old][j][0] + 2 * a[j][i]);        dp[st][i][3] = min(dp[st][i][3], dp[st_old][j][2]);        dp[st][i][3] = min(dp[st][i][3], dp[st_old][j][1] + 2 * a[j][i]);      &#125;    &#125;  &#125;  ll ans = 1e18;  for (int i = 1; i &lt;= n; i++) &#123;    ans = min(ans, dp[(1 &lt;&lt; n) - 1][i][3]);  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","每日一题","哈密顿路径","状压dp"]},{"title":"题解-ranko的手表","url":"/2026/02/03/%E9%A2%98%E8%A7%A3-ranko%E7%9A%84%E6%89%8B%E8%A1%A8/","content":"题目链接\n 题意\n\n给定两个字符串a,b,表示时间,其中有一些位置会被?替代\n你可以将?替换为任意数字\n保证两时间在同一天,且第一个时间早于第二个时间\n求解两个时间的差值(分钟)的最小值和最大值\n\n 思路\n\n写起来比较费劲的题,提供一种比较方便的思路\n枚举一天中的分钟[0,24∗60)[0,24*60)[0,24∗60),检查当前的分钟数对给出的两个字符串是否合法\n把两个串对应的合法答案存入两个数组中\n暴力枚举两个数组找答案\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  string a, b;  cin &gt;&gt; a &gt;&gt; b;  int t = 24 * 60, mxt = -1, mnt = 101010;  vector&lt;int&gt; aa, bb;  for (int i = 0; i &lt; t; i++) &#123;    int h = i / 60;    int m = i % 60;    if ((a[0] == &#x27;?&#x27; || a[0] - &#x27;0&#x27; == h / 10) &amp;&amp;        (a[1] == &#x27;?&#x27; || a[1] - &#x27;0&#x27; == h % 10) &amp;&amp;        (a[3] == &#x27;?&#x27; || a[3] - &#x27;0&#x27; == m / 10) &amp;&amp;        (a[4] == &#x27;?&#x27; || a[4] - &#x27;0&#x27; == m % 10)) &#123;      aa.push_back(i);    &#125;    if ((b[0] == &#x27;?&#x27; || b[0] - &#x27;0&#x27; == h / 10) &amp;&amp;        (b[1] == &#x27;?&#x27; || b[1] - &#x27;0&#x27; == h % 10) &amp;&amp;        (b[3] == &#x27;?&#x27; || b[3] - &#x27;0&#x27; == m / 10) &amp;&amp;        (b[4] == &#x27;?&#x27; || b[4] - &#x27;0&#x27; == m % 10)) &#123;      bb.push_back(i);    &#125;  &#125;  for (auto _aa : aa) &#123;    for (auto _bb : bb) &#123;      if (_bb &gt; _aa) &#123;        mxt = max(mxt, _bb - _aa);        mnt = min(mnt, _bb - _aa);      &#125;    &#125;  &#125;  cout &lt;&lt; mnt &lt;&lt; &#x27; &#x27; &lt;&lt; mxt &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","枚举"]},{"title":"题解-不相邻取数","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E4%B8%8D%E7%9B%B8%E9%82%BB%E5%8F%96%E6%95%B0/","content":"题目链接\n 题意\n\n给定长为n的序列,取出一些不相邻的数,求能获得的最大和\n\n 思路\n\n由于前两天被方案类的dp折磨了,所以也写了个方案dp解法\n歪解:\n\n把dp的状态做成二维,dp[i][0/1]表示前i个数,第i个数选取/不选取能获得的最大和\n转移方程:\n\n\ndp[i][0]=max(dp[i−1][0],dp[i−1][1])dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])\ndp[i][0]=max(dp[i−1][0],dp[i−1][1])\n\n\ndp[i][1]=max(a[i],a[i]+dp[i−1][0])dp[i][1] = max(a[i], a[i] + dp[i - 1][0])\ndp[i][1]=max(a[i],a[i]+dp[i−1][0])\n\n\n\n\n\n正解:\n\n线性dp\n定义dp[i]表示前i个数能获得的最大和\n转移方程:\n\n\ndp[i]=max(dp[i−1],dp[i−2]+a[i])dp[i] = max(dp[i - 1], dp[i - 2] + a[i])\ndp[i]=max(dp[i−1],dp[i−2]+a[i])\n\n\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;/** * dp[n][2] * dp[i][0]=max(dp[i-1][0],dp[i-1][1]) * dp[i][1]=max(a[i],a[i]+dp[i-1][0]) * 初始化:全0就行 */int main() &#123;  ios::sync_with_stdio(false);  cin.tie(0), cout.tie(0);  int n;  cin &gt;&gt; n;  vector&lt;ll&gt; a(n + 10);  vector&lt;vector&lt;ll&gt;&gt; dp(n + 10, vector&lt;ll&gt;(2));  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  for (int i = 1; i &lt;= n; i++) &#123;    dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);    dp[i][1] = max(a[i], a[i] + dp[i - 1][0]);    // cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; dp[i][0] &lt;&lt; &#x27; &#x27; &lt;&lt; dp[i][1] &lt;&lt; endl;  &#125;  cout &lt;&lt; max(dp[n][0], dp[n][1]) &lt;&lt; endl;  return 0;&#125;\n","categories":["算法竞赛"],"tags":["线性dp","题解"]},{"title":"题解-Boredom","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-Boredom/","content":"题目链接\n 题意\n\n给定一个长为n的数组a,可以进行任意次操作\n每次操作选择序列中的一个元素aia_iai​,删掉aia_iai​,获得aia_iai​的分值,同时删除所有值为ai+1,ai−1a_i+1,a_i-1ai​+1,ai​−1的元素\n求解能获得的最大分数\n\n 思路\n\n线性dp变种\n数组的原顺序是不重要的,我们其实更在乎的是能拿哪些值\n如果我们拿了一个值x,那么所有值为x的元素我们都会拿,所以删除和取都应该是全拿全删\n所以数组的形态不重要,更重要的是获得每个值出现的次数\n我们可以用一个map来记录每个值出现的次数,然后用一个dp数组来记录能获得的最大分数\n那么就变成了经典的不相邻取数问题\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  map&lt;int, int&gt; mp;  int mx = 0;  for (int i = 1; i &lt;= n; i++) &#123;    int x;    cin &gt;&gt; x;    mp[x]++;    mx = max(x, mx);  &#125;  vector&lt;ll&gt; dp(mx + 10, 0);  dp[1] = mp[1];  for (int i = 2; i &lt;= mx; i++) &#123;    dp[i] = max(dp[i - 1], dp[i - 2] + mp[i] * i);  &#125;  cout &lt;&lt; dp[mx] &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["线性dp","妙妙题","题解"]},{"title":"题解-x_to_y_2","url":"/2026/01/18/%E9%A2%98%E8%A7%A3-x-to-y-2/","content":"题目链接\n 题意\n\n给定两个整数x和y,可以进行如下两种操作:\n\nx=⌊x2⌋x=\\lfloor \\frac{x}{2} \\rfloorx=⌊2x​⌋\n选定任意数字zzz,x=x∣zx=x|zx=x∣z\n\n\n求最少多少次操作能让xxx变为yyy\n\n 思路\n\n拆位来看,想让x变成y,y已经为1的部分只需要和x进行一次|即可完成\n但y为0的部分无法通过|完成,所以只能通过移位,直到x剩余的所有位都能和y对上,这时候在看情况进行|操作\n看什么情况呢:如果移位完后x==y就不需要|操作了\n\n 代码\n#include&lt;bits/stdc++.h&gt;using namespace std;void solve()&#123;    long long x,y;    cin &gt;&gt; x &gt;&gt; y ;    if(x==y) cout &lt;&lt; 0 &lt;&lt; endl;    else if ((x|y)==y) cout &lt;&lt; 1 &lt;&lt; endl;    else&#123;        int cnt=0;        while(x)&#123;            if((x|y)==y) break;            x&gt;&gt;=1;            cnt++;        &#125;        cout &lt;&lt; cnt+1 &lt;&lt; endl;    &#125;&#125;int main()&#123;    int t;    cin &gt;&gt; t;    while(t--)&#123;        solve();    &#125;    return 0;&#125;","categories":["算法竞赛"],"tags":["位运算","题解"]},{"title":"题解-NIM游戏","url":"/2026/01/30/%E9%A2%98%E8%A7%A3-NIM%E6%B8%B8%E6%88%8F/","content":"题目链接\n\n老记不住,写两笔\n\n 题意\n\nn堆石子,每堆aia_iai​个\n两人依次取子,每次可以拿走一堆中任意个\n拿走最后一个石子的赢\n判断先手赢还是后手赢\n\n 思路\n\n设S=⊕i=1naiS=\\oplus_{i=1}^n a_iS=⊕i=1n​ai​\n如果S=0S=0S=0,则先手必败\n否则,先手必胜\n证明如下\n\n显然S=0S=0S=0,是一个必败态,并且进行任何操作一定会进入S!=0S!=0S!=0\n下证任何一个S!=0S!=0S!=0的情况下都能一步转移到S=0S=0S=0,即S!=0S!=0S!=0是必胜态\n\n对于S!=0S!=0S!=0,存在最高位的1,记为第k位,那么在石堆中一定有aia_iai​,使得aia_iai​的第k位为1\n此时ai′=ai⊕Sa_{i}&#x27;=a_i\\oplus Sai′​=ai​⊕S的最高位一定低于aia_iai​,所以ai′&lt;aia_i&#x27;&lt;a_iai′​&lt;ai​\n从aia_iai​中取走若干石子,变为ai′a_i&#x27;ai′​,则此时异或和S′=0S&#x27;=0S′=0,进入必败态\n证毕\n\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  int sum = 0;  for (int i = 1; i &lt;= n; i++) &#123;    int x;    cin &gt;&gt; x;    sum ^= x;  &#125;  cout &lt;&lt; (sum ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","博弈论"]},{"title":"题解-nico和niconiconi","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-nico%E5%92%8Cniconiconi/","content":"题目链接\n 题意\n\n给定一个长为n字符串s\n其中字串nico,niconi,niconiconi的价值分别是A,B,C\n统计该字符串能获得的最大值\n\n 思路\n\n线性dp\n只不过换了一种形式,依旧是dp[i]表示到第i位能获得的最大价值\n只不过每次检查当前位置作为末尾能不能提取出一个上述三种字串\n转移方程\n\n\n没有匹配的上的\ndp[i]=dp[i−1]dp[i]=dp[i-1]\ndp[i]=dp[i−1]\n\n\n匹配上nico\ndp[i]=max(dp[i−1],dp[i−4]+A)dp[i]=max(dp[i-1],dp[i-4]+A)\ndp[i]=max(dp[i−1],dp[i−4]+A)\n\n\n剩余的同理\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n, a, b, c;  string s;  cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;  cin &gt;&gt; s;  s = &#x27; &#x27; + s;  vector&lt;ll&gt; dp(n + 1, 0);  for (int i = 1; i &lt;= n; i++) &#123;    dp[i] = max(dp[i], dp[i - 1]);    if (i &gt;= 4 &amp;&amp; s.substr(i - 3, 4) == &quot;nico&quot;) &#123;      dp[i] = max(dp[i], dp[i - 4] + a);    &#125;    if (i &gt;= 6 &amp;&amp; s.substr(i - 5, 6) == &quot;niconi&quot;) &#123;      dp[i] = max(dp[i], dp[i - 6] + b);    &#125;    if (i &gt;= 10 &amp;&amp; s.substr(i - 9, 10) == &quot;niconiconi&quot;) &#123;      dp[i] = max(dp[i], dp[i - 10] + c);    &#125;  &#125;  cout &lt;&lt; dp[n] &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n","categories":["算法竞赛"],"tags":["线性dp","题解"]},{"title":"题解-区间翻转","url":"/2026/01/18/%E9%A2%98%E8%A7%A3-%E5%8C%BA%E9%97%B4%E7%BF%BB%E8%BD%AC/","content":"\n题目链接\n\n 题意\n\n给定一个排列,最开始是{1,2,…,n}\n进行k次操作\n每次翻转区间[l,r],特别的,区间起始点和终点是非递减的\n\n对于i&lt;j,一定有li&lt;=lj且ri&lt;=rj\n\n\n输出k次操作后的序列\n1&lt;n,k&lt;1e5\n\n 思路\n\n观察发现,记排序p对于当前的区间[l,r],由于非递减,所以p的前l-1个数已经确定了\n同时,由于非递减,所以随着区间的上升,只有可能发生两个事情\n\nl变大,确定的数变多\nr变大,加入更多不确定的数字\n\n\n因此,用一个deque维护当前仍然不确定的数字,并同时用一个布尔变量rev模拟翻转的过程,那么每次操作如下\n\n遍历每一个区间\n如果cur_r&lt;r:新增元素入队\n\nrev=false:区间没翻转直接push_back\nrev=true:区间翻转,所谓的队尾实际应该是队头,push_front\n\n\n如果curl&gt;l:已经毕业的元素弹出\n\nrev=false:区间没翻转直接pop_front\nrev=true:区间翻转,弹出的队首实际上是队尾pop_back\n\n\n每处理完一个区间都要翻转:rev=!rev以此规避模拟过程\n更新cur_l,cur_r\n\n\n注意:\n\n所有区间处理完后,记得处理没排完的数(队列里剩下的&amp;&amp;没入过队的)\n最前面的几个数不用处理,因为前面的数在更新r的时候会强制入队\n\n\n\n 代码\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);cout.tie(0);    int n,k;    cin &gt;&gt; n &gt;&gt; k;    deque&lt;int&gt; dq;    vector&lt;int&gt; ans;    bool rev=false;    int l,r,prel=1,prer=0;    for(int i=0;i&lt;k;i++)&#123;        cin &gt;&gt; l &gt;&gt; r;        if(prer&lt;r)&#123;            for(int j=prer+1;j&lt;=r;j++)&#123;                // cout &lt;&lt; &quot;&gt;&gt;&quot; &lt;&lt; j &lt;&lt; &#x27; &#x27; &lt;&lt; rev &lt;&lt; endl;                if(rev) dq.push_front(j);                else dq.push_back(j);            &#125;        &#125;        if(prel&lt;l)&#123;            for(int j=prel;j&lt;l;j++)&#123;                if(!rev)&#123;                    ans.push_back(dq.front());                    // cout &lt;&lt; &quot;&lt;&lt;&quot; &lt;&lt; dq.front() &lt;&lt; &#x27; &#x27; &lt;&lt; rev &lt;&lt; endl;                    dq.pop_front();                &#125;                else&#123;                    ans.push_back(dq.back());                    // cout &lt;&lt; &quot;&lt;&lt;&quot; &lt;&lt; dq.back() &lt;&lt; &#x27; &#x27; &lt;&lt; rev &lt;&lt; endl;                    dq.pop_back();                &#125;            &#125;        &#125;        prel=l;prer=r;        rev=!rev;    &#125;    while(!dq.empty())&#123;        if(!rev)&#123;            ans.push_back(dq.front());            dq.pop_front();        &#125;else&#123;            ans.push_back(dq.back());            dq.pop_back();        &#125;    &#125;    for(auto i:ans)&#123;        cout &lt;&lt; i &lt;&lt; &#x27; &#x27; ;    &#125;    for(int i=prer+1;i&lt;=n;i++)&#123;        cout &lt;&lt; i &lt;&lt; &#x27; &#x27; ;    &#125;    cout &lt;&lt; endl;    return 0;&#125;","categories":["算法竞赛"],"tags":["题解","deque"]},{"title":"题解-宵暗的妖怪","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E5%AE%B5%E6%9A%97%E7%9A%84%E5%A6%96%E6%80%AA/","content":"题目链接\n 题意\n\n给定一个长为n的序列\n可以选择连续的3个元素,删除,获得中间那个元素的值\n求能获得的最大值\n\n 思路\n\n歪解:\n\n依旧方案dp\ndp[i][1/0]前i个元素,选择/不选择第i个元素,能获得的最大值\n转移方程:\n\n\ndp[i][0]=max(dp[i−1][0],dp[i−1][1])dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])\ndp[i][0]=max(dp[i−1][0],dp[i−1][1])\n\n\ndp[i][1]=a[i−1]+max(dp[i−3][0],dp[i−3][1])dp[i][1] = a[i - 1] + max(dp[i - 3][0], dp[i - 3][1])\ndp[i][1]=a[i−1]+max(dp[i−3][0],dp[i−3][1])\n\n\n\n\n\n正解:\n\n线性dp\ndp[i]表示前i个数能获得的最大值\n转移方程:\n\n\ndp[i]=max(dp[i−1],dp[i−3]+a[i−1])dp[i]=max({dp[i-1],dp[i-3]+a[i-1]})\ndp[i]=max(dp[i−1],dp[i−3]+a[i−1])\n\n\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;long long&gt; a(n + 10);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  vector&lt;long long&gt; dp(n + 10);  dp[1] = a[1];  dp[2] = max(0ll, a[1] + a[2]);  for (int i = 3; i &lt;= n; i++) &#123;    dp[i] = max(&#123;dp[i - 2], dp[i - 3], dp[i - 1] + a[i]&#125;);  &#125;  cout &lt;&lt; dp[n] &lt;&lt; endl;&#125;int main() &#123;  int t;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["线性dp","题解"]},{"title":"题解-小彩的数组构造","url":"/2026/01/30/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E5%BD%A9%E7%9A%84%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0/","content":"题目链接\n 题意\n\n给定a,b,ca,b,ca,b,c\n构造一个序列,使得\n\n有a个长为3的子数组和为1的倍数\n有b个长为3的子数组和为2的倍数\n有c个长为3的子数组和为3的倍数\n\n\n若不存在这样的序列,输出-1\n\n 思路\n\n\n知识补充–中国剩余定理\n\n有n个两两互质的整数m1,m2,...,mnm_1,m_2,...,m_nm1​,m2​,...,mn​,对于任意一组余数a1,a2,...,ana_1,a_2,...,a_na1​,a2​,...,an​,方程组{x≡a1(modm1)x≡a2(modm2)…x≡an(modmn)\\begin{cases}\nx \\equiv a_1 \\pmod{m_1} \\\\\nx \\equiv a_2 \\pmod{m_2} \\\\\n\\dots \\\\\nx \\equiv a_n \\pmod{m_n}\n\\end{cases}\n⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​x≡a1​(modm1​)x≡a2​(modm2​)…x≡an​(modmn​)​\n\n在模 M=m1⋅m2⋅⋯⋅mnM = m_1 \\cdot m_2 \\cdot \\dots \\cdot m_nM=m1​⋅m2​⋅⋯⋅mn​ 的意义下，有且仅有一个唯一解XXX\n求法如下\n\n计算所有模数的乘积 M=∏miM = \\prod m_iM=∏mi​。\n对于每一个方程 iii：\n\n计算 Mi=M/miM_i = M / m_iMi​=M/mi​ （即除了 mim_imi​ 以外其他所有模数的乘积）\n计算 MiM_iMi​ 在模 mim_imi​ 意义下的逆元 tit_iti​（满足 Miti≡1(modmi)M_i t_i \\equiv 1 \\pmod{m_i}Mi​ti​≡1(modmi​),等价于在模mim_imi​意义下消去了MiM_iMi​）\n\n\n最终解为：X=∑(ai⋅Mi⋅ti)(modM)X = \\sum (a_i \\cdot M_i \\cdot t_i) \\pmod M\nX=∑(ai​⋅Mi​⋅ti​)(modM)\n\n\n\n\n\n\n第一个条件限定死了数组长度为a+2\n\n\n对于每一个长为3的子数组,固定住前两个,剩下的那个元素由中国剩余定理求,在1~6之间一定有解,暴力填充即可\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int a, b, c;  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;  if (b &gt; a || c &gt; a) &#123;    cout &lt;&lt; -1 &lt;&lt; endl;    return;  &#125;  cout &lt;&lt; a + 2 &lt;&lt; endl;  int pre1 = 1, pre2 = 1;  for (int i = 3; i &lt;= a + 2; i++) &#123;    int sum = pre1 + pre2;    cout &lt;&lt; pre1 &lt;&lt; &#x27; &#x27;;    pre1 = pre2;    if (i &lt;= b + 2 &amp;&amp; i &lt;= c + 2) &#123;      for (int i = 1; i &lt;= 6; i++) &#123;        if (!((sum + i) % 3) &amp;&amp; !((sum + i) % 2)) &#123;          pre2 = i;          break;        &#125;      &#125;    &#125; else if (i &lt;= b + 2) &#123;      for (int i = 1; i &lt;= 6; i++) &#123;        if ((sum + i) % 3 &amp;&amp; !((sum + i) % 2)) &#123;          pre2 = i;          break;        &#125;      &#125;    &#125; else if (i &lt;= c + 2) &#123;      for (int i = 1; i &lt;= 6; i++) &#123;        if ((sum + i) % 2 &amp;&amp; !((sum + i) % 3)) &#123;          pre2 = i;          break;        &#125;      &#125;    &#125; else &#123;      for (int i = 1; i &lt;= 6; i++) &#123;        if ((sum + i) % 2 &amp;&amp; (sum + i) % 3) &#123;          pre2 = i;          break;        &#125;      &#125;    &#125;  &#125;  cout &lt;&lt; pre1 &lt;&lt; &#x27; &#x27; &lt;&lt; pre2 &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["构造","题解","数学","中国剩余定理"]},{"title":"题解-小红删数字","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E7%BA%A2%E5%88%A0%E6%95%B0%E5%AD%97/","content":"每日一题1.21\n 题意\n\n给定长为n的数组,进行n-1此操作,剩下一个数字\n每次操作选定最后两个数x,y,删除\n然后加入(x+y)%10或者x*y%10\n统计,所有可能的操作下,最终结果为0,1,…,9的方案数各有多少\n结果对1e9+7取模\nn&lt;=2e5,a&lt;=1e9\n\n 思路\n\n\n对于最后的情况需要知道所有可能的方案,考虑dp\n\n\n设dp[i][j]表示i次操作,最后一个数字是j的方案数\n\n\n那么,按照下面的公式从后往前递推即可\ndp[i−1][(j+a[i−1])%10]=dp[i−1][(j+a[i−1])%10]+dp[i][j]dp[i-1][(j+a[i-1])\\%10]=dp[i-1][(j+a[i-1])\\%10]+dp[i][j]\ndp[i−1][(j+a[i−1])%10]=dp[i−1][(j+a[i−1])%10]+dp[i][j]\ndp[i−1][(j∗a[i−1])%10]=dp[i−1][(j∗a[i−1])%10]+dp[i][j]dp[i-1][(j*a[i-1])\\%10]=dp[i-1][(j*a[i-1])\\%10]+dp[i][j]\ndp[i−1][(j∗a[i−1])%10]=dp[i−1][(j∗a[i−1])%10]+dp[i][j]\n\n\n坑:n是可以取1的,如果一次操作都做不了且输入的数字大于10,那么方案数应该全是0,得特判\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int p = 1e9 + 7;long long dp[202020][10];long long a[202020];int main() &#123;  int n;  cin &gt;&gt; n;  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  if (n &lt;= 1 &amp;&amp; a[1] &gt;= 10) &#123;    for (int i = 0; i &lt; 10; i++) &#123;      cout &lt;&lt; 0 &lt;&lt; &#x27; &#x27;;    &#125;    return 0;  &#125;  dp[n][a[n] % 10] = 1;  for (int i = n; i &gt;= 1; i--) &#123;    for (int j = 0; j &lt; 10; j++) &#123;      dp[i - 1][(j + a[i - 1]) % 10] =          (dp[i - 1][(j + a[i - 1]) % 10] + dp[i][j]) % p;      dp[i - 1][(j * a[i - 1]) % 10] =          (dp[i - 1][(j * a[i - 1]) % 10] + dp[i][j]) % p;    &#125;  &#125;  for (int i = 0; i &lt;= 9; i++) &#123;    cout &lt;&lt; dp[1][i] &lt;&lt; &#x27; &#x27;;  &#125;  cout &lt;&lt; endl;  return 0;&#125;","categories":["算法竞赛"],"tags":["方案dp","题解","每日一题"]},{"title":"题解-小红的双排列删除得分","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E7%BA%A2%E7%9A%84%E5%8F%8C%E6%8E%92%E5%88%97%E5%88%A0%E9%99%A4%E5%BE%97%E5%88%86/","content":"题目链接\n 题意\n\n给定一个长为2n的双排列,可以进行如下操作任意次:\n\n选定一个首尾元素相等的区间[l,r]\n删除这个区间,获得区间中所有值的和\n\n\n求出可能的最高分\n\n 思路\n\n线性dp,很神奇的思路\ndp[i]依旧表示前i个元素的最高分\n怎么转移?\n\n对于第i个元素,可以删也可以不删\n删掉的话需要快速的获得上一次的位置和区间和\n维护两个数组即可\n\n\n转移方程\n\n\ndp[i]=max(dp[i−1],dp[a[i]上一次出现的位置−1]+区间和)dp[i]=max(dp[i-1],dp[a[i]上一次出现的位置-1]+区间和)\ndp[i]=max(dp[i−1],dp[a[i]上一次出现的位置−1]+区间和)\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;long long&gt; a(n + 10);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  vector&lt;long long&gt; dp(n + 10);  dp[1] = a[1];  dp[2] = max(0ll, a[1] + a[2]);  for (int i = 3; i &lt;= n; i++) &#123;    dp[i] = max(&#123;dp[i - 2], dp[i - 3], dp[i - 1] + a[i]&#125;);  &#125;  cout &lt;&lt; dp[n] &lt;&lt; endl;&#125;int main() &#123;  int t;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["线性dp","妙妙题","题解"]},{"title":"题解-小美的数组操作","url":"/2026/02/03/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E7%BE%8E%E7%9A%84%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/","content":"题目链接\n 题意\n\n给定一个长为n的数组,你可以进行如下操作任意次\n选定数组中的两个元素,给其中一个+1,另一个-1\n求使得数组众数出现次数最多时最小操作数是多少\n\n 思路\n\n维护一个sum\n如果sum整除n,那么一定可以使得所有数一样,直接计算所需操作数即可\n如果sum不整除n,那么众数最多只能出现n-1次,则数组的最终形态是n-1个众数x,1个工具数y\n\n需要解决两个问题:选择哪n-1个数变为x?x应该取几?\nx和y一定存在大小关系,也就是必然有y&gt;x||y&lt;x\n贪心的考虑,希望操作次数最小,一定希望原来数组里的最大数/最小数变成y\n为了操作数最少,我们希望减少n-1个数和外部的交换,因为x变动1,y就要变动n-1\n所以x的选取应当是取n-1个数的平均值附近(上取整/下取整),枚举检验即可\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  ll sum = 0;  vector&lt;ll&gt; a(n + 10);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];    sum += a[i];  &#125;  if (sum % n == 0) &#123;    ll ans = 0;    for (int i = 1; i &lt;= n; i++) &#123;      ans += abs(a[i] - sum / n);    &#125;    ans /= 2;    cout &lt;&lt; ans &lt;&lt; endl;  &#125; else &#123;    sort(a.begin() + 1, a.begin() + n + 1);    ll nsum = sum - a[1];    ll tar = nsum / (n - 1);    ll ans = LLONG_MAX;    ll rst = 0;    for (int i = 2; i &lt;= n; i++) &#123;      rst += abs(a[i] - tar);    &#125;    rst += nsum - (n - 1) * tar;    rst /= 2;    ans = min(ans, rst);    rst = 0;    tar = nsum / (n - 1) + 1;    for (int i = 2; i &lt;= n; i++) &#123;      rst += abs(a[i] - tar);    &#125;    rst += (n - 1) * tar - nsum;    rst /= 2;    ans = min(ans, rst);    nsum = sum - a[n];    tar = nsum / (n - 1);    rst = 0;    for (int i = 1; i &lt;= n - 1; i++) &#123;      rst += abs(a[i] - tar);    &#125;    rst += nsum - (n - 1) * tar;    rst /= 2;    ans = min(ans, rst);    rst = 0;    tar = nsum / (n - 1) + 1;    for (int i = 1; i &lt;= n - 1; i++) &#123;      rst += abs(a[i] - tar);    &#125;    rst += (n - 1) * tar - nsum;    rst /= 2;    ans = min(ans, rst);    cout &lt;&lt; ans &lt;&lt; endl;  &#125;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["思维","题解","每日一题"]},{"title":"题解-小红蹦跳蹦跳","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E7%BA%A2%E8%B9%A6%E8%B7%B3%E8%B9%A6%E8%B7%B3/","content":"题目链接\n 题意\n\n一个n级台阶,交替上升奇数步/偶数步\n第一步可以任意选择,每一步一定和上一步奇偶性不同\n求上n级台阶的方案数\n\n 思路\n\n\n对于某一个位置,如果下一步要走奇数/偶数,那么上一步一定是偶数/奇数\n\n\n所以用dp[i][1/0]表示到第i级,下一步是奇数/偶数的方案数\n\n\n具体转移方案如下\n  i是奇数:dp[i][0]=sum(dp[偶数][1])dp[i][1]=sum(dp[奇数][0])i是偶数:dp[i][0]=sum(dp[奇数][1])dp[i][1]=sum(dp[偶数][0])\n\n\n然后会发现,dp无意义,只有4个sum有意义,维护4个sum即可\n\n\n 代码\n\n优化:发现dp数组其实无意义,只需要记录当前状态\n\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int p = 1e9 + 7;void solve() &#123;  int n;  cin &gt;&gt; n;  ll cur_0 = 0, cur_1 = 0;  vector&lt;vector&lt;ll&gt;&gt; sum(2, vector&lt;ll&gt;(2));  for (int i = 1; i &lt;= n; i++) &#123;    cur_0 = sum[1 - (i % 2)][1];    cur_1 = sum[i % 2][0];    if (i % 2)      cur_0++;    else      cur_1++;    sum[i % 2][0] = (sum[i % 2][0] + cur_0) % p;    sum[i % 2][1] = (sum[i % 2][1] + cur_1) % p;  &#125;  cout &lt;&lt; (cur_0 + cur_1) % p &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n\n不优化\n\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int p = 1e9 + 7;/** * i是奇数 * dp[i][0]=sum(dp[偶数][1]) * dp[i][1]=sum(dp[奇数][0]) * i是偶数 * dp[i][0]=sum(dp[奇数][1]) * dp[i][1]=sum(dp[偶数][0]) */void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;vector&lt;ll&gt;&gt; dp(n + 10, vector&lt;ll&gt;(2));  vector&lt;vector&lt;ll&gt;&gt; sum(2, vector&lt;ll&gt;(2));  for (int i = 1; i &lt;= n; i++) &#123;    dp[i][0] = sum[1 - (i % 2)][1];    dp[i][1] = sum[i % 2][0];    dp[i][1 - i % 2]++;    sum[i % 2][0] = (sum[i % 2][0] + dp[i][0]) % p;    sum[i % 2][1] = (sum[i % 2][1] + dp[i][1]) % p;  &#125;  cout &lt;&lt; (dp[n][0] + dp[n][1]) % p &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n","categories":["算法竞赛"],"tags":["线性dp","题解"]},{"title":"题解-小红的rpg游戏","url":"/2026/02/03/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E7%BA%A2%E7%9A%84rpg%E6%B8%B8%E6%88%8F/","content":"题目链接\n 题意\n\nn*m的迷宫,有墙*,有怪物数字表示血量\n最开始位于右上角,给定初始hp,hp&lt;=0就死亡,求走到左下角的最短路径\n\n 思路\n\n深搜会TLE,因为深搜会遍历整个图很多遍\n广搜第一次走到一定就是最短的,所以用广搜\nBFS的vis数组需要开三维vis[x][y][hp],因为走到同一个点不同的血量对应的最终状态可能是不同的\n所以血量需要单独开一维\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;struct ty &#123;  int first;  int second;  int dep;&#125;;string G[55];bool vis[55][55][55];int ans = INT_MAX;int n, m, h;int dir[4][2] = &#123;0, 1, 0, -1, -1, 0, 1, 0&#125;;void bfs() &#123;  queue&lt;ty&gt; q;  q.push(&#123;0, h, 0&#125;);  while (!q.empty()) &#123;    ty tmp = q.front();    q.pop();    int x = tmp.first / m;    int y = tmp.first % m;    int step = tmp.dep;    if (x == n - 1 &amp;&amp; y == m - 1) &#123;      ans = step;      return;    &#125;    int hh = tmp.second;    for (int i = 0; i &lt; 4; i++) &#123;      int tx = x + dir[i][0];      int ty = y + dir[i][1];      int nhh = hh;      if (tx &lt; 0 || ty &lt; 0 || tx &gt;= n || ty &gt;= m || vis[tx][ty][nhh] ||          G[tx][ty] == &#x27;*&#x27;)        continue;      if (G[tx][ty] &lt;= &#x27;9&#x27; &amp;&amp; G[tx][ty] &gt;= &#x27;0&#x27;)        nhh -= G[tx][ty] - &#x27;0&#x27;;      if (nhh &lt;= 0)        continue;      vis[tx][ty][nhh] = 1;      q.push(&#123;tx * m + ty, nhh, step + 1&#125;);    &#125;  &#125;&#125;void solve() &#123;  cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;  for (int i = 0; i &lt; n; i++) &#123;    cin &gt;&gt; G[i];  &#125;  bfs();  cout &lt;&lt; (ans == INT_MAX ? -1 : ans) &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","BFS"]},{"title":"题解-小苯的序列合并","url":"/2026/02/11/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E8%8B%AF%E7%9A%84%E5%BA%8F%E5%88%97%E5%90%88%E5%B9%B6/","content":"每日一题2.11\n 题意\n\n给定长为nnn的序列,你可以做如下操作任意次\n\n将任意两个相邻元素合并,合并后的权值为ai⊕ai+1a_i\\oplus a_{i+1}ai​⊕ai+1​\n\n\n求操作结束后所有数字按位与的最大值\n\n 思路\n\n对于整个序列最后会变成若干段连续异或的与和\n考虑将序列分为几段\n\n情况一:整个序列分成一段,那么结果就是整个数组的异或和\n情况二:分成偶数段,可以证明分成大于二的段数一定不如分成两段好\n\n如果分成四段,对于最优的ans的最高位,一定是四个1求与,那么四段异或和一定可以分为1|3的异或,两边都保证了最高位是1,且与能保证是1的地方异或一定也保证了是1,而与为0的地方,异或可能是1,所以异或更优\n因此枚举所有的两段方案即可\n\n\n情况三:分成超过一段的奇数段,这种情况下同情况二的两个奇数段,异或本身就优于与,所以会变为一段,回归第一种情况\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;#define endl &#x27;\\n&#x27;using ll = long long;using pii = pair&lt;int, int&gt;;using pll = pair&lt;long long, long long&gt;;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;int&gt; a(n + 1);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];    a[i] ^= a[i - 1];  &#125;  int ans = a[n];  for (int i = 1; i &lt; n; i++) &#123;    ans = max(ans, a[i] &amp; (a[n] ^ a[i]));  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["位运算","题解","每日一题"]},{"title":"题解-小苯的最大和","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E8%8B%AF%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/","content":"题目链接\n 题意\n\n给定一个长为n的序列a,可以进行如下操作:\n\n选取两个相邻数字,删除,把剩余数字拼接起来\n选取三个连续数字,删除,把剩余数字拼接起来\n\n\n你可以执行任意次,想知道a的总和最大可以达到多少?\n\n 思路\n\n线性dp\n定义dp[i]表示a的前i个数字的最大和\\\n状态转移:\n\n\ndp[i]=max(dp[i−2],dp[i−3],dp[i−1]+a[i])dp[i] = max({dp[i - 2], dp[i - 3], dp[i - 1] + a[i]})\ndp[i]=max(dp[i−2],dp[i−3],dp[i−1]+a[i])\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;long long&gt; a(n + 10);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  vector&lt;long long&gt; dp(n + 10);  dp[1] = a[1];  dp[2] = max(0ll, a[1] + a[2]);  for (int i = 3; i &lt;= n; i++) &#123;    dp[i] = max(&#123;dp[i - 2], dp[i - 3], dp[i - 1] + a[i]&#125;);  &#125;  cout &lt;&lt; dp[n] &lt;&lt; endl;&#125;int main() &#123;  int t;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["线性dp","题解"]},{"title":"题解-岛屿数量","url":"/2026/02/05/%E9%A2%98%E8%A7%A3-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/","content":"题目链接\n 题意\n\nn∗mn*mn∗m的地图上,有若干用W标记的地点,表示岛屿\n如果一个W的八个相邻方向上有相邻的W,就认为两个W是联通的,属于同一片岛屿\n求解整片地图上共有多少W构成的岛屿\n\n 思路\n\nDFS经典题\n读入完后对所有没访问的W做dfs,每次dfs给cnt++\ndfs只标记不消除,这样子每个连通块就只会被标记一次\n注意vis的写法\n\n vis到底怎么写\n\nvis到底写在dfs枚举的里面还是外面?\n并不固定而是看处理类型\n对于本题而言,进入dfs代表着当前点已经被访问了,已经处理完毕,vis应当直接把当前点标记\n而对于其它类型,如这道题,进入dfs后才处理当前位应当填写什么,所以在处理过程进行vis标记\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using pii = pair&lt;int, int&gt;;int n, m;string mp[110];bool vis[110][110];int cnt = 0;int dir[8][2] = &#123;1, 0, -1, 0, 0, 1, 0, -1, 1, 1, -1, -1, 1, -1, -1, 1&#125;;void dfs(int x, int y) &#123;  vis[x][y] = 1;  for (int i = 0; i &lt; 8; i++) &#123;    int tx = x + dir[i][0];    int ty = y + dir[i][1];    if (vis[tx][ty] || tx &lt; 0 || ty &lt; 0 || tx &gt;= n || ty &gt;= m ||        mp[tx][ty] != &#x27;W&#x27;)      continue;    dfs(tx, ty);  &#125;&#125;void solve() &#123;  cin &gt;&gt; n &gt;&gt; m;  for (int i = 0; i &lt; n; i++) &#123;    cin &gt;&gt; mp[i];  &#125;  for (int i = 0; i &lt; n; i++) &#123;    for (int j = 0; j &lt; m; j++) &#123;      if (mp[i][j] == &#x27;W&#x27; &amp;&amp; vis[i][j] == false) &#123;        dfs(i, j);        cnt++;      &#125;    &#125;  &#125;  cout &lt;&lt; cnt &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","dfs"]},{"title":"题解-收集金币","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-%E6%94%B6%E9%9B%86%E9%87%91%E5%B8%81/","content":"题目链接\n 题意\n\nn*m迷宫,每个格子里有aija_{ij}aij​个金币,初始在(1,1),只能向右向下移动\n有t条信息,(x,y,i),表示(x,y)这个位置,在第i秒后就不可通过\n求最多能获得的金币数\n\n 思路\n\n线性dp小变形\n观察发现,由于只能向右/向下走,所以到达每个格子的时间是固定的\n\n以1-base下标为例t=x+y-2\n\n\n所以信息给出后哪些格子能到哪些不能到就确定了\n两种写法:\n\n写法一:\n\n把不能到的格子处理成一个负的极大值,这样自然就不会走\n\n\n写法二:\n\n转移的时候判断一下是否是不可访问的格子,如果是,就不转移\n\n\n\n\n最后遍历所有位置,找最大值\n\n 代码\n//写法一#include &lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;using ll = long long;void solve() &#123;  int n, m, t;  cin &gt;&gt; n &gt;&gt; m;  vector&lt;vector&lt;ll&gt;&gt; a(n + 10, vector&lt;ll&gt;(m + 10));  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= m; j++) &#123;      cin &gt;&gt; a[i][j];    &#125;  &#125;  cin &gt;&gt; t;  for (int i = 1; i &lt;= t; i++) &#123;    int x, y, z;    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;    if (x + y - 2 &gt;= z)      a[x][y] = -1e9;  &#125;  vector&lt;vector&lt;ll&gt;&gt; dp(n + 10, vector&lt;ll&gt;(m + 10, -1e9));  dp[1][0] = 0;  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= m; j++) &#123;      dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + a[i][j];    &#125;  &#125;  ll ans = 0;  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= m; j++) &#123;      ans = max(ans, dp[i][j]);    &#125;  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n//写法二for (int i = 1; i &lt;= n; ++i) &#123;    for (int j = 1; j &lt;= m; ++j) &#123;        if (i == 1 &amp;&amp; j == 1) continue;        // 检查当前格子是否可达        int arrival_time = i + j - 2;        if (arrival_time &gt;= wall_time[i][j]) &#123;            continue; // 此格子无法进入        &#125;        long long from_up = -INF;        if (i &gt; 1 &amp;&amp; dp[i - 1][j] != -INF) &#123;            from_up = dp[i - 1][j];        &#125;        long long from_left = -INF;        if (j &gt; 1 &amp;&amp; dp[i][j - 1] != -INF) &#123;            from_left = dp[i][j - 1];        &#125;        long long prev_max = max(from_up, from_left);        if (prev_max != -INF) &#123;            dp[i][j] = prev_max + coins[i][j];        &#125;    &#125;&#125;","categories":["算法竞赛"],"tags":["线性dp","题解"]},{"title":"题解-最长不下降子序列","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/","content":"题目链接\n 题意\n\n给定一个长为n的序列,计算最长不下降子序列长度\nn&lt;=5e3\n\n 思路\n\ndp[i]表示前i个数,必须取第i个数的情况下的最长不下降子序列\n由于题目范围允许O(n^2),所以很容易想到,每次和前面所有的所比较\n转移方程:\n\n\ndp[i]=max(dp[j]+1)   (a[i]&gt;=a[j]且j&lt;i)dp[i]=max(dp[j]+1)\\,\\,\\,(a[i]&gt;=a[j]且j&lt;i)\ndp[i]=max(dp[j]+1)(a[i]&gt;=a[j]且j&lt;i)\n\n最后答案从全部dp[i]dp[i]dp[i]中取max\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;ll&gt; a(n + 10, 0);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  vector&lt;ll&gt; dp(n + 10, 1);  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt; i; j++) &#123;      if (a[i] &gt;= a[j])        dp[i] = max(dp[i], dp[j] + 1);    &#125;  &#125;  ll ans = 0;  for (int i = 1; i &lt;= n; i++) &#123;    ans = max(ans, dp[i]);  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["线性dp","题解"]},{"title":"题解-[模板]点线位置关系","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-%E6%A8%A1%E6%9D%BF-%E7%82%B9%E7%BA%BF%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB/","content":"题目链接\n 题意\n\n给定三个点A,B,C,求解C和AB之间的关系\n\nC在AB的左边\nC在AB的右边\nC在线段AB上\nC在直线AB上\n\n\n\n 思路\n\n向量叉积:两个向量的叉积的正负反映了两向量的相对位置关系\n$AB\\times AC = |AB|\\cdot|AC|sin(&lt;AB,AC&gt;) =x_{AB}y_{AC}-x_{AC}y_{AB} $\n叉积为正,角度为正,在左侧\n反之为右侧\n叉积为0,贡献,判断C的坐标范围和AB的坐标范围\n如何判断范围\n\nC的横纵坐标均在max(A横纵坐标,B横纵坐标)和min(A横纵坐标,B横纵坐标)之间才可以\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;#define pll pair&lt;long long, long long&gt;#define fi first#define se secondusing namespace std;using ll = long long;ll CrossMul(pll a, pll b, pll c) &#123;  return (b.fi - a.fi) * (c.se - a.se) - (c.fi - a.fi) * (b.se - a.se);&#125;void solve() &#123;  pll a, b, c;  cin &gt;&gt; a.fi &gt;&gt; a.se &gt;&gt; b.fi &gt;&gt; b.se &gt;&gt; c.fi &gt;&gt; c.se;  ll jdg = CrossMul(a, b, c);  if (jdg &gt; 0)    cout &lt;&lt; 1 &lt;&lt; endl;  else if (jdg &lt; 0)    cout &lt;&lt; 2 &lt;&lt; endl;  else if (jdg == 0 &amp;&amp; (c.fi &gt;= min(a.fi, b.fi) &amp;&amp; c.fi &lt;= max(a.fi, b.fi))&amp;&amp; (c.se &gt;= min(a.se, b.se) &amp;&amp; c.se &lt;= max(a.se, b.se)))    cout &lt;&lt; 3 &lt;&lt; endl;  else    cout &lt;&lt; 4 &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","计算几何","模板"]},{"title":"题解-[模板]点圆位置关系","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-%E6%A8%A1%E6%9D%BF-%E7%82%B9%E5%9C%86%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB/","content":"题目链接\n 题意\n\n给定圆心O,半径r,点P\n判断P和圆O之间的关系\n如果P在圆外,输出两个切点\n\n 思路\n\n判断其实很好做,直接拿|AP|和r比较即可\n切点怎么找\n\n如果纯解析几何会比较坐牢\n用一个小巧思\n\n由于AO长度和r是已知的,又因为相切\n所以在切线,半径,AO构成的直角三角形中,圆心角的余弦是已知的cosθ=r∣AO∣cos\\theta=\\frac{r}{|AO|}cosθ=∣AO∣r​\n进而可以求得圆心角θ\\thetaθ\n然后两个切点的位置其实就是AO绕O顺/逆时针旋转θ\\thetaθ后和圆的交点,然后就能找到切点了\n\n\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;using namespace std;using ll = long long;const double eps = 1e-8; // 精度误差允许范围const double PI = acos(-1.0);// 符号函数：用来处理精度问题int dcmp(double x) &#123;  if (fabs(x) &lt; eps)    return 0;  return x &lt; 0 ? -1 : 1;&#125;struct Point &#123;  double x, y;  Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;  Point operator+(const Point &amp;B) const &#123; return Point(x + B.x, y + B.y); &#125;  Point operator-(const Point &amp;B) const &#123; return Point(x - B.x, y - B.y); &#125;  Point operator*(double k) const &#123; return Point(x * k, y * k); &#125;  Point operator/(double k) const &#123; return Point(x / k, y / k); &#125;  // 判等 (精度敏感)  bool operator==(const Point &amp;B) const &#123;    return dcmp(x - B.x) == 0 &amp;&amp; dcmp(y - B.y) == 0;  &#125;&#125;;typedef Point Vector;// 点积double Dot(Vector A, Vector B) &#123; return A.x * B.x + A.y * B.y; &#125;// 叉积double Cross(Vector A, Vector B) &#123; return A.x * B.y - A.y * B.x; &#125;// 模double Length(Vector A) &#123; return sqrt(Dot(A, A)); &#125;// 模方double Length2(Vector A) &#123; return Dot(A, A); &#125;// 夹角(弧度)double Angle(Vector A, Vector B) &#123;  return acos(Dot(A, B) / Length(A) / Length(B));&#125;// 将向量 A 逆时针旋转 rad 弧度Vector Rotate(Vector A, double rad) &#123;  return Vector(A.x * cos(rad) - A.y * sin(rad),                A.x * sin(rad) + A.y * cos(rad));&#125;void solve() &#123;  Point O, A;  int r;  cin &gt;&gt; O.x &gt;&gt; O.y &gt;&gt; r &gt;&gt; A.x &gt;&gt; A.y;  double len_oa = Length(A - O);  if (len_oa &lt; r)    cout &lt;&lt; 1 &lt;&lt; endl;  else if (fabs(len_oa - r) &lt; eps)    cout &lt;&lt; 2 &lt;&lt; endl;  else &#123;    Vector OA = A - O;    Vector OB = Rotate(OA * (r / len_oa), acos(r / len_oa));    Vector OC = Rotate(OA * (r / len_oa), -1 * acos(r / len_oa));    cout &lt;&lt; 3 &lt;&lt; &#x27; &#x27; &lt;&lt; (O + OB).x &lt;&lt; &#x27; &#x27; &lt;&lt; (O + OB).y &lt;&lt; &#x27; &#x27; &lt;&lt; (O + OC).x         &lt;&lt; &#x27; &#x27; &lt;&lt; (O + OC).y &lt;&lt; endl;  &#125;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  cout &lt;&lt; fixed &lt;&lt; setprecision(12);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","计算几何","模板"]},{"title":"题解-幂次接近","url":"/2026/02/04/%E9%A2%98%E8%A7%A3-%E5%B9%82%E6%AC%A1%E6%8E%A5%E8%BF%91/","content":"每日一题2.4\n 题意\n\n给定ttt次询问,每次询问给出两个正整数nnn和kkk\n请找到最小的正整数mmm,使得n−mkn−m^kn−mk的绝对值最小\n\n 思路\n\n画图发现所求其实就是方程n−mk=0n−m^k=0n−mk=0时的mmm\n答案是单调的,考虑二分\n做一个check判断当前值是否大于0\n最后二分结束后\n\nl:函数小于等于0的第一个取值\nr:函数大于0的第一个取值\n\n\n检验一下lll和rrr哪个更合适即可\n特别的:由于kkk的范围可能很大,快速幂会溢出,快速幂里面需要使用__int128优化,并处理basebasebase和rstrstrst\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll n, k;ll qpow(ll a, ll b) &#123;  __int128 base = a;  __int128 rst = 1;  const ll lim = LLONG_MAX;  while (b) &#123;    if (b &amp; 1) &#123;      rst *= base;      if (rst &gt; lim)        return lim;    &#125;    base *= base;    if (b &gt; 1 &amp;&amp; base &gt; lim)      base = lim;    b &gt;&gt;= 1;  &#125;  return (ll)rst;&#125;bool check(ll x) &#123; return n - qpow(x, k) &gt; 0; &#125;void solve() &#123;  cin &gt;&gt; n &gt;&gt; k;  ll l = 1, r = n;  while (l &lt;= r) &#123;    ll mid = (l + r) &gt;&gt; 1;    if (check(mid))      l = mid + 1;    else      r = mid - 1;  &#125;  cout &lt;&lt; (abs(n - qpow(l, k)) &lt; abs(n - qpow(r, k)) ? l : r) &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["二分答案","题解","每日一题"]},{"title":"题解-小红选点","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E7%BA%A2%E9%80%89%E7%82%B9/","content":"题目链接\n 题意\n\nn个点,找出欧几里得距离最大的两个并输出\nn&lt;=1000\n\n 思路\n\nO(n2)O(n^2)O(n2)做法\n\n反正就1000个点,暴力枚举计算一遍就行\n\n\nO(nlog(n))O(nlog(n))O(nlog(n))做法\n\n求凸包直径\n不会\n后面补\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;#include &lt;vector&gt;using namespace std;using ll = long long;void solve() &#123;  int n;  cin &gt;&gt; n;  vector&lt;pair&lt;int, int&gt;&gt; a(n + 10);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i].first &gt;&gt; a[i].second;  &#125;  ll x, y, mxdis = 0;  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt; i; j++) &#123;      int x1 = a[i].first;      int y1 = a[i].second;      int x2 = a[j].first;      int y2 = a[j].second;      if ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) &gt; mxdis) &#123;        x = i;        y = j;        mxdis = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);      &#125;    &#125;  &#125;  cout &lt;&lt; a[x].first &lt;&lt; &#x27; &#x27; &lt;&lt; a[x].second &lt;&lt; &#x27; &#x27; &lt;&lt; a[y].first &lt;&lt; &#x27; &#x27;       &lt;&lt; a[y].second &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","计算几何","未完成"]},{"title":"题解-[模板]点线最近距离","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-%E6%A8%A1%E6%9D%BF-%E7%82%B9%E7%BA%BF%E6%9C%80%E8%BF%91%E8%B7%9D%E7%A6%BB/","content":"题目链接\n 题意\n\n已知三点A,B,C,维护一个数据结构,使其能支持\n\n输出点C到直线AB的最近距离\n输出点C到线段AB的最近距离\n输出点C到直线AB的最近点的坐标\n输出点C到线段AB的最近点的坐标\n\n\n\n 思路\n\n核心其实是找到C在AB上的投影点P,如果P不在AB范围,就特殊处理\n由点乘定义∣AP∣=AC⋅ABAB|AP|=\\frac{AC \\cdot AB}{AB}∣AP∣=ABAC⋅AB​,然后可以得到P点坐标,然后接解决了\n\n实现的时候为了避免开根号带来的误差,可以直接除AB的模的平方,算AP在AB上的占比\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const double eps = 1e-8; // 精度误差允许范围const double PI = acos(-1.0);// 符号函数：用来处理精度问题int dcmp(double x) &#123;  if (fabs(x) &lt; eps)    return 0;  return x &lt; 0 ? -1 : 1;&#125;struct Point &#123;  double x, y;  Point(double x = 0, double y = 0) : x(x), y(y) &#123;&#125;  Point operator+(const Point&amp; B) const &#123;    return Point(x + B.x, y + B.y);  &#125;  Point operator-(const Point&amp; B) const &#123;    return Point(x - B.x, y - B.y);  &#125;  Point operator*(double k) const &#123;    return Point(x * k, y * k);  &#125;  Point operator/(double k) const &#123;    return Point(x / k, y / k);  &#125;  // 判等 (精度敏感)  bool operator==(const Point&amp; B) const &#123;    return dcmp(x - B.x) == 0 &amp;&amp; dcmp(y - B.y) == 0;  &#125;&#125;;typedef Point Vector;// 点积double Dot(Vector A, Vector B) &#123;  return A.x * B.x + A.y * B.y;&#125;// 叉积double Cross(Vector A, Vector B) &#123;  return A.x * B.y - A.y * B.x;&#125;// 模double Length(Vector A) &#123;  return sqrt(Dot(A, A));&#125;// 模方double Length2(Vector A) &#123;  return Dot(A, A);&#125;// 夹角(弧度)double Angle(Vector A, Vector B) &#123;  return acos(Dot(A, B) / Length(A) / Length(B));&#125;void solve() &#123;  cout &lt;&lt; fixed &lt;&lt; setprecision(10);  int op;  cin &gt;&gt; op;  Point a, b, c;  cin &gt;&gt; a.x &gt;&gt; a.y &gt;&gt; b.x &gt;&gt; b.y &gt;&gt; c.x &gt;&gt; c.y;  Vector ab = b - a, ac = c - a;  double rate = Dot(ab, ac) / Length2(ab);  Point p = a + ab * rate;  if (op == 1)    cout &lt;&lt; p.x &lt;&lt; &#x27; &#x27; &lt;&lt; p.y &lt;&lt; endl;  else if (op == 2)    cout &lt;&lt; Length(p - a - ac) &lt;&lt; endl;  else if (op == 3) &#123;    if (rate &lt;= 0)      cout &lt;&lt; a.x &lt;&lt; &#x27; &#x27; &lt;&lt; a.y &lt;&lt; endl;    else if (rate &gt;= 1)      cout &lt;&lt; b.x &lt;&lt; &#x27; &#x27; &lt;&lt; b.y &lt;&lt; endl;    else      cout &lt;&lt; p.x &lt;&lt; &#x27; &#x27; &lt;&lt; p.y &lt;&lt; endl;  &#125; else &#123;    if (rate &lt;= 0)      cout &lt;&lt; Length(ac) &lt;&lt; endl;    else if (rate &gt;= 1)      cout &lt;&lt; Length(c - b) &lt;&lt; endl;    else      cout &lt;&lt; Length(p - a - ac) &lt;&lt; endl;  &#125;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","计算几何","模板"]},{"title":"题解-小红的数组选数","url":"/2026/01/31/%E9%A2%98%E8%A7%A3-%E5%B0%8F%E7%BA%A2%E7%9A%84%E6%95%B0%E7%BB%84%E9%80%89%E6%95%B0/","content":"题目链接\n 题意\n\n给定一个长为n的数组,从中选取一些数字,使其加和为k\n请问有多少种选法\n1&lt;=n&lt;=20\n\n 思路\n\n显然暴力枚举是可以的,2^20不会爆炸\n但是怎么枚举?\n\n其实这里的枚举有点类似于状压DP中对状态的枚举\n开一个(1&lt;&lt;20)-1的变量表示每一个数字选取/不选取\n暴力搞就可以了\n\n\nemmm,比较有意思的枚举方式,记录一下\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  int n, k;  cin &gt;&gt; n &gt;&gt; k;  vector&lt;int&gt; a(n + 10);  for (int i = 0; i &lt; n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  ll ans = 0;  for (int i = 0; i &lt;= (1 &lt;&lt; n) - 1; i++) &#123;    ll sum = 0;    for (int j = 0; j &lt; n; j++) &#123;      if ((i &gt;&gt; j) &amp; 1)        sum += a[j];    &#125;    if (sum == k)      ans++;  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n","categories":["算法竞赛"],"tags":["题解","枚举"]},{"title":"题解-躲藏","url":"/2026/02/03/%E9%A2%98%E8%A7%A3-%E8%BA%B2%E8%97%8F/","content":"每日一题2.2\n 题意\n\n给定字符串s,不区分大小写,求解cwbc作为子序列出现的次数\n\n 思路\n\n经典的子序列匹配计数问题使用dp来解决\ndp[i][0/1/2/3]dp[i][0/1/2/3]dp[i][0/1/2/3]表示到第iii位,c/cw/cwb/cwbc的数量\n转移方程dp[i][0/1/2/3]=dp[i−1][0/1/2/3]+dp[i−1][−/0/1/2]dp[i][0/1/2/3]=dp[i-1][0/1/2/3]+dp[i-1][-/0/1/2]dp[i][0/1/2/3]=dp[i−1][0/1/2/3]+dp[i−1][−/0/1/2]\n第一维可以压缩掉\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;void solve() &#123;  string s;  cin &gt;&gt; s;  ll dp[4] = &#123;0&#125;;  for (auto c : s) &#123;    if (c == &#x27;c&#x27; || c == &#x27;C&#x27;)      dp[0]++;    if (c == &#x27;w&#x27; || c == &#x27;W&#x27;)      dp[1] += dp[0];    if (c == &#x27;b&#x27; || c == &#x27;B&#x27;)      dp[2] += dp[1];    if (c == &#x27;c&#x27; || c == &#x27;C&#x27;)      dp[3] += dp[2];  &#125;  cout &lt;&lt; dp[3] % 2000120420010122 &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","每日一题","动态规划"]},{"title":"题解-矩阵的最小路径和","url":"/2026/01/21/%E9%A2%98%E8%A7%A3-%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","content":" 题意\n\nn*m矩阵,起点(1,1),只能向右向下走,求从起点到终点的最小路径和\nn,m&lt;=2000,内存限制:32MB\n\n 思路\n\ndp的想法很简单,处理初值即可\n但是直接开二维数组就会炸(2000*2000*8=32MB,还要考虑其他部分),必须滚动\n发现用到的信息是上一行的同一位置和同一行左侧位置,所以直接就地顺序滚动即可\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123;  int n, m;  cin &gt;&gt; n &gt;&gt; m;  vector&lt;vector&lt;int&gt;&gt; a(n + 10, vector&lt;int&gt;(m + 10));  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= m; j++) &#123;      cin &gt;&gt; a[i][j];    &#125;  &#125;  vector&lt;long long&gt; dp(m + 10, 1e18);  for (int i = 1; i &lt;= n; i++) &#123;    for (int j = 1; j &lt;= m; j++) &#123;      if (i == 1 &amp;&amp; j == 1)        dp[j] = a[i][j];      else        dp[j] = a[i][j] + min(dp[j], dp[j - 1]);    &#125;  &#125;  cout &lt;&lt; dp[m] &lt;&lt; endl;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","就地滚动"]},{"title":"题解-阅读理解","url":"/2026/01/19/%E9%A2%98%E8%A7%A3-%E9%98%85%E8%AF%BB%E7%90%86%E8%A7%A3/","content":"每日一题-1.19\n 题意\n\nn句话,m次查询,每次查询一个word,升序输出所有出现过word的句子编号\n没出现就输出空行\n\n 思路\n\n\n纯暴力做法\n\n对于每句话维护一个set,每次查询从n个set中查找word\n复杂度是O(nm*log(一句话单词数L)*一个词的字母数S)\ntips:字符串的比较复杂度是要算长度的\n\n\n\n有脑做法:\n\n倒排索引\n不再建立set,而是建立word到句子编号的映射map&lt;string,set&lt;int&gt;&gt;\n这样查询的时候只用遍历word对应的set即可\n复杂度是O(m*S*log(总单词数))\n\n\n\n 代码\n//更优写法#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    map&lt;string,set&lt;int&gt;&gt; mp;    int n;    cin &gt;&gt; n;    for(int i=1;i&lt;=n;i++)&#123;        int x;        cin &gt;&gt; x;        for(int j=0;j&lt;x;j++)&#123;            string s;            cin &gt;&gt; s;            mp[s].insert(i);        &#125;    &#125;    int m;    cin &gt;&gt; m;    for(int i=0;i&lt;m;i++)&#123;        string s;        cin &gt;&gt; s;        if(!mp[s].empty())&#123;            for(auto x:mp[s])&#123;                cout &lt;&lt; x &lt;&lt; &#x27; &#x27; ;            &#125;            cout &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;// #include&lt;bits/stdc++.h&gt;// using namespace std;// int main()&#123;//     int n;//     cin &gt;&gt; n;//     vector&lt;set&lt;string&gt;&gt; a(n);//     for(int i=0;i&lt;n;i++)&#123;//         int x;//         cin &gt;&gt; x;//         for(int j=0;j&lt;x;j++)&#123;//             string s;//             cin &gt;&gt; s;//             a[i].insert(s);//         &#125;//     &#125;//     int m;//     cin &gt;&gt; m;//     for(int i=0;i&lt;m;i++)&#123;//         string check;//         cin &gt;&gt; check;//         for(int j=0;j&lt;n;j++)&#123;//             if(a[j].count(check))&#123;//                 cout &lt;&lt; j+1 &lt;&lt; &#x27; &#x27; ;//             &#125;//         &#125;//         cout &lt;&lt; endl;//     &#125;//     return 0;// &#125;","categories":["算法竞赛"],"tags":["题解","每日一题"]},{"title":"题解-计数","url":"/2026/01/29/%E9%A2%98%E8%A7%A3-%E8%AE%A1%E6%95%B0/","content":"每日一题1.29\n 题意\n\n给定长为nnn的单调不增序列,元素范围1&lt;=ai&lt;=10001&lt;=a_i&lt;=10001&lt;=ai​&lt;=1000,其中有一部分元素缺失了,缺失元素记为0\n你需要填充序列,使其仍然为单调不增,求解方案数\n1&lt;=n&lt;=1e61&lt;=n&lt;=1e61&lt;=n&lt;=1e6\n\n 思路\n\n歪解不出来:\n\n最开始看计数,想着能不能线性dp搞一下\n\ndp[i][j]dp[i][j]dp[i][j] 表示前iii个数,最后一个数是jjj的序列数\n初始化:dp[1][a[i]]=1\n如果a[i]a[i]a[i]是确定的:dp[i][a[i]]=sum(dp[i−1][j])(j&lt;=a[i])dp[i][a[i]]=sum(dp[i-1][j]) (j&lt;=a[i])dp[i][a[i]]=sum(dp[i−1][j])(j&lt;=a[i])\n如果a[i]a[i]a[i]是0:dp[i][1 1000]=sum(dp[i−1][1 1000])dp[i][1~1000]=sum(dp[i-1][1~1000])dp[i][1 1000]=sum(dp[i−1][1 1000])\n数组是开不下的,得滚动\n先从头到尾扫一遍前缀和,维护sum[1000]sum[1000]sum[1000]\n然后dp就可以压缩掉第一维\n新一位a[i]=0a[i]=0a[i]=0 -&gt; dp=sumdp=sumdp=sum\n否则 dp[a[i]]=sum[a[i]]dp[a[i]]=sum[a[i]]dp[a[i]]=sum[a[i]],其它位赋值0\n然后重复更新前缀和\n复杂度O(1000∗n)O(1000*n)O(1000∗n),GG\n\n\n\n\n正解\n\n能对方案数产生贡献的其实就是序列中所有的零串\n考虑分别计算每个零串的贡献\n对每个零串,记长度为kkk\n其中能填入的数字已经确定了,最大就填入零串开始前的那个数字,最小填零串结尾的数字,记为[R,L][R,L][R,L],如果零串位于序列开始/结尾,则分别对应[R,1000][R,1000][R,1000]和[1,L][1,L][1,L]\n那么对于每个零串能产生的贡献,就是从[R,L][R,L][R,L]中可重复的选取kkk个数\n然后贡献乘到一起就解决了\n\n\n组合数学\n\n组合数怎么算\n\n根据组合数定义式Cnm=n!m!(n−m)!C_n^m=\\frac{n!}{m!(n-m)!}Cnm​=m!(n−m)!n!​\n维护一个阶乘数组fact\n维护一个阶乘逆元数组invfact\n\n逆元计算是费马小定理,p是质数且a不是p的倍数情况下有:ap−1≡1 (mod p)a^{p-1}\\equiv 1\\ (\\text{mod }p)\nap−1≡1 (mod p)\n\n所以1a≡ap−2 (mod p)\\frac{1}{a}\\equiv a^{p-2}\\ (\\text{mod }p)\na1​≡ap−2 (mod p)\n\n\n\n\n\n可重组合\n\n对于nnn个数里可重复的拿取mmm次的方案数,记为HnmH_n^mHnm​公式如下Hnm=Cn+m−1mH_n^m=C_{n+m-1}^m\nHnm​=Cn+m−1m​\n\n证明如下:\n\nnnn个拿取mmm次,其实等价于把mmm个球分配到nnn个盒子里\n这个问题类似于隔板法,用n−1n-1n−1个隔板,隔开mmm个球,但这时的隔板可以插在两边,并且也可以插在同一个位置\n最后就等价于在n+m−1n+m-1n+m−1个位置中,取出mmm个位置来放球,等价于Cn+m−1mC_{n+m-1}^mCn+m−1m​\n\n\n\n\n\n\n\n 代码\n\n\n写法上,两种写法\n\n\n一种是末尾加入一个强制结尾1,维护一个变量up,初值为1000,每次扫到0就计次,扫到非零元素就计算,并更新up\n\n\n一种是头和尾都加入,然后只记录非零元素,遍历相邻非零元素,计算结果\n\n\n写法一\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int p = 1e9 + 7;ll invfac[1010101], fac[1010101];ll qpow(ll a, ll b) &#123;  ll ans = 1;  a %= p;  while (b) &#123;    if (b &amp; 1)      ans = ans * a % p;    a = a * a % p;    b &gt;&gt;= 1;  &#125;  return ans;&#125;void calc() &#123;  fac[0] = 1;  invfac[0] = 1;  for (int i = 1; i &lt; 1010101; i++) &#123;    fac[i] = i * fac[i - 1] % p;    invfac[i] = qpow(fac[i], p - 2);  &#125;&#125;void solve() &#123;  calc();  int n;  cin &gt;&gt; n;  vector&lt;ll&gt; a(n + 10);  for (int i = 1; i &lt;= n; i++) &#123;    cin &gt;&gt; a[i];  &#125;  a[n + 1] = 1;  ll ans = 1, up = 1000, cnt = 0;  for (int i = 1; i &lt;= n + 1; i++) &#123;    if (a[i]) &#123;      ll t = up - a[i] + cnt;      ans = (ans * fac[t] % p * invfac[cnt] % p * invfac[t - cnt] % p);      cnt = 0;      up = a[i];    &#125; else      cnt++;  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;\n\n写法二\n\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int p = 1e9 + 7;ll invfac[1010101], fac[1010101];ll qpow(ll a, ll b) &#123;  ll ans = 1;  a %= p;  while (b) &#123;    if (b &amp; 1)      ans = ans * a % p;    a = a * a % p;    b &gt;&gt;= 1;  &#125;  return ans;&#125;void calc() &#123;  fac[0] = 1;  invfac[0] = 1;  for (int i = 1; i &lt; 1010101; i++) &#123;    fac[i] = i * fac[i - 1] % p;    invfac[i] = qpow(fac[i], p - 2);  &#125;&#125;void solve() &#123;  calc();  int n;  cin &gt;&gt; n;  vector&lt;ll&gt; a, b;  a.push_back(1000);  b.push_back(0);  for (int i = 1; i &lt;= n; i++) &#123;    int x;    cin &gt;&gt; x;    if (x != 0) &#123;      a.push_back(x);      b.push_back(i);    &#125;  &#125;  a.push_back(1);  b.push_back(n + 1);  ll ans = 1;  for (int i = 0; i &lt; a.size() - 1; i++) &#123;    ll lidx = b[i], lval = a[i];    ll ridx = b[i + 1], rval = a[i + 1];    if (ridx - lidx &gt; 1) &#123;      ll cnt = ridx - lidx - 1;      ll t = (lval - rval + 1) + cnt - 1;      ans = ans * fac[t] % p * invfac[cnt] % p * invfac[t - cnt] % p;    &#125;  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["妙妙题","题解","每日一题","组合数学"]},{"title":"题解-游游的二进制树","url":"/2026/01/28/%E9%A2%98%E8%A7%A3-%E6%B8%B8%E6%B8%B8%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%91/","content":"每日一题1.27\n 题意\n\n给定一棵树，树上有 nnn 个节点，编号为 111 到 nnn\n每个节点的权值为111或000\n一条路径的权值是所有节点的000和111构成的二进制值\n给出l,r,求权值在[l,r]之间的路径的数量\n特别的,只有一个点的路径不算\nn&lt;=1e3\n\n 思路\n\n点不多,考虑搜索\ndfs维护当前的累计权值和,每次判断是否在[l,r]之间\n剪枝:如果当前的累计权值sum&gt;⌊r2⌋sum&gt;\\lfloor\\frac{r}{2}\\rfloorsum&gt;⌊2r​⌋,就不需要继续搜索,因为下一步一定会大于r\n由于考虑的是所有可能的路径,所以需要从每个点开始都搜一遍\n关于vis数组的使用\n\n树的遍历可以只维护father节点,进而不使用vis数组\n一般图的dfs和所有bfs都需要维护vis数组\nvis的意义在于给图封住一部分路\n\n\n\n 代码\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;ll l, r, sum;int vis[1010];string s;vector&lt;int&gt; G[1010];void dfs(int fa, int x, ll val) &#123;  if (val &gt; r)    return;  if (val &gt;= l &amp;&amp; val &lt;= r &amp;&amp; fa != 0) &#123;    sum++;  &#125;  for (auto tx : G[x]) &#123;    if (tx == fa)      continue;    dfs(x, tx, (val &lt;&lt; 1) + (s[tx] - &#x27;0&#x27;));  &#125;&#125;void solve() &#123;  int n;  cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;  cin &gt;&gt; s;  s = &#x27; &#x27; + s;  for (int i = 1; i &lt; n; i++) &#123;    int x, y;    cin &gt;&gt; x &gt;&gt; y;    G[x].push_back(y);    G[y].push_back(x);  &#125;  for (int i = 1; i &lt;= n; i++)    dfs(0, i, s[i] - &#x27;0&#x27;);  cout &lt;&lt; sum &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","每日一题","DFS"]},{"title":"题解-邮递员送信","url":"/2026/01/23/%E9%A2%98%E8%A7%A3-%E9%82%AE%E9%80%92%E5%91%98%E9%80%81%E4%BF%A1/","content":"每日一题1.23\n 题意\n\nn个点,m条单向边,每条边有权值,最开始在1\n求访问每一个点再回来的权值和\nn&lt;1e3\n\n\n 思路\n\n一眼最短路\n笨比做法:\n\n跑一遍从1开始的dijkstra,累加到每个点的最短路\n然后跑一边剩余点开始的dijkstra,累加回1的最短路\n\n\n正解:\n\n想求每个点到1的最短路,其实就是把图反着建,然后从1开始跑dijkstra\n\n\n特别的,dijkstra的剪枝不用vis数组,直接用距离剪枝,这样可以少维护一个数组,且时间效率不变\n\n 代码\n#include &lt;bits/stdc++.h&gt;#define pll pair&lt;long long, long long&gt;using namespace std;using ll = long long;ll dis[1010];vector&lt;pll&gt; GG[1010];vector&lt;pll&gt; RG[1010];struct cmp &#123;  bool operator()(pll &amp;a, pll &amp;b) &#123; return a.first &gt; b.first; &#125;&#125;;void dijkstra(int st, vector&lt;pll&gt; G[]) &#123;  fill(dis, dis + 1010, 1e18);  priority_queue&lt;pll, vector&lt;pll&gt;, cmp&gt; pq;  dis[st] = 0;  pq.push(&#123;0, st&#125;);  while (!pq.empty()) &#123;    pll tmp = pq.top();    pq.pop();    // 剪枝    ll d = tmp.first;    ll u = tmp.second;    if (d &gt; dis[u])      continue;    for (auto [val, to] : G[tmp.second]) &#123;      if (dis[to] &gt; dis[tmp.second] + val) &#123;        dis[to] = dis[tmp.second] + val;        pq.push(&#123;dis[to], to&#125;);      &#125;    &#125;  &#125;&#125;void solve() &#123;  int n, m;  cin &gt;&gt; n &gt;&gt; m;  for (int i = 1; i &lt;= m; i++) &#123;    int x, y, v;    cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;    GG[x].push_back(&#123;v, y&#125;);    RG[y].push_back(&#123;v, x&#125;);  &#125;  dijkstra(1, GG);  ll ans = 0;  for (int i = 2; i &lt;= n; i++) &#123;    ans += dis[i];  &#125;  dijkstra(1, RG);  for (int i = 2; i &lt;= n; i++) &#123;    ans += dis[i];  &#125;  cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;  ios::sync_with_stdio(false);  cin.tie(nullptr);  int t = 1;  // cin &gt;&gt; t;  while (t--) &#123;    solve();  &#125;  return 0;&#125;","categories":["算法竞赛"],"tags":["题解","每日一题","图论","最短路","反向建图"]}]